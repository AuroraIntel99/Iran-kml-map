<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>OpenLayers KML Map (Folder Toggles)</title>
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/ol@latest/ol.css" />
  <script src="https://cdn.jsdelivr.net/npm/dompurify@3.1.6/dist/purify.min.js"></script>
  <style>
    :root{
      --panel-w:340px;--border:rgba(0,0,0,.15);--bg:rgba(255,255,255,.92);
      --shadow:0 8px 24px rgba(0,0,0,.18);--radius:10px;
      --font:system-ui,-apple-system,Segoe UI,Roboto,Arial,sans-serif;
    }
    html,body{height:100%;margin:0;padding:0;font-family:var(--font);}
    #app{height:100%;width:100%;display:grid;grid-template-columns:var(--panel-w) 1fr;}
    #map{width:100%;height:100%;}
    #panel{background:var(--bg);border-right:1px solid var(--border);overflow:hidden;display:grid;grid-template-rows:auto auto auto 1fr auto;}
    #panelHeader{padding:12px 12px 10px;border-bottom:1px solid var(--border);}
    #panelHeader h1{margin:0 0 6px;font-size:15px;font-weight:800;}
    #panelHeader .sub{margin:0;font-size:12px;opacity:.75;line-height:1.3;}
    #controls{padding:10px 12px;border-bottom:1px solid var(--border);display:grid;gap:8px;}
    #search{width:100%;box-sizing:border-box;padding:9px 10px;border-radius:10px;border:1px solid var(--border);outline:none;font-size:13px;background:rgba(255,255,255,.95);}
    #toggles{display:flex;gap:8px;align-items:center;flex-wrap:wrap;font-size:12px;opacity:.9;}
    .pill{display:inline-flex;align-items:center;gap:6px;padding:6px 10px;border:1px solid var(--border);border-radius:999px;background:rgba(255,255,255,.85);cursor:pointer;user-select:none;}
    .pill input{margin:0;}
    #foldersWrap{padding:10px 12px;border-bottom:1px solid var(--border);overflow:auto;max-height:34vh;}
    #foldersTitle{display:flex;justify-content:space-between;gap:10px;align-items:center;margin:0 0 8px 0;font-size:13px;font-weight:750;}
    .smallbtn{border:1px solid var(--border);background:rgba(255,255,255,.9);padding:5px 8px;border-radius:999px;cursor:pointer;font-size:12px;}
    .folder{display:flex;align-items:flex-start;gap:8px;padding:6px 0;}
    .folder input{margin-top:2px;}
    .folder .name{font-size:12.5px;line-height:1.2;}
    .folder .count{font-size:12px;opacity:.7;margin-left:auto;white-space:nowrap;}
    #featureList{overflow:auto;padding:0;margin:0;list-style:none;}
    .item{padding:10px 12px;border-bottom:1px solid rgba(0,0,0,.06);cursor:pointer;display:grid;gap:4px;}
    .item:hover{background:rgba(0,0,0,.035);}
    .item .name{font-size:13px;font-weight:650;}
    .item .meta{font-size:12px;opacity:.75;}
    #panelFooter{padding:10px 12px;border-top:1px solid var(--border);font-size:12px;opacity:.75;display:flex;justify-content:space-between;gap:10px;align-items:center;flex-wrap:wrap;}
    @media (max-width:820px){
      #app{grid-template-columns:1fr;}
      #panel{position:absolute;z-index:10;width:min(92vw,var(--panel-w));height:calc(100% - 20px);left:10px;top:10px;border:1px solid var(--border);border-radius:var(--radius);box-shadow:var(--shadow);transform:translateX(calc(-100% - 16px));transition:transform .25s ease;}
      #panel.open{transform:translateX(0);}
      #panelToggleBtn{position:absolute;z-index:11;left:10px;top:10px;background:var(--bg);border:1px solid var(--border);border-radius:999px;box-shadow:var(--shadow);padding:8px 10px;font-size:13px;cursor:pointer;}
    }
    .ol-popup{position:absolute;background:#fff;padding:12px 12px 10px;border-radius:10px;border:1px solid rgba(0,0,0,.25);bottom:12px;left:-50px;min-width:240px;max-width:min(520px,calc(100vw - 24px));box-shadow:var(--shadow);font-size:14px;line-height:1.35;}
    .ol-popup-closer{text-decoration:none;position:absolute;top:6px;right:8px;font-size:18px;color:rgba(0,0,0,.55);}
    .ol-popup-closer:hover{color:rgba(0,0,0,.85);}
    .popup-title{font-weight:800;margin:0 70px 6px 0;font-size:15px;}
    .popup-nav{display:flex;gap:8px;align-items:center;margin:8px 0 0;font-size:12px;opacity:.9;}
    .btn{border:1px solid var(--border);background:rgba(255,255,255,.9);padding:6px 10px;border-radius:999px;cursor:pointer;user-select:none;}
    .btn:disabled{opacity:.45;cursor:default;}
    .hint{position:absolute;top:10px;right:10px;background:var(--bg);border:1px solid var(--border);padding:8px 10px;border-radius:10px;font-size:12px;box-shadow:var(--shadow);}
    .err{position:absolute;left:10px;bottom:10px;background:rgba(255,245,245,.95);border:1px solid rgba(180,0,0,.25);color:rgba(120,0,0,.9);padding:10px 12px;border-radius:10px;font-size:12px;box-shadow:var(--shadow);max-width:min(760px,calc(100vw - 24px));display:none;white-space:pre-wrap;}
  
    /* Popup HTML description styling */
    #popup-content table{border-collapse:collapse;width:100%;margin:6px 0 8px 0;font-size:12.5px;}
    #popup-content th,#popup-content td{border:1px solid rgba(0,0,0,.15);padding:4px 6px;vertical-align:top;}
    #popup-content th{background:rgba(0,0,0,.04);font-weight:700;}
    #popup-content a{color:inherit;text-decoration:underline;}
    #popup-content .descHtml{margin:0 0 8px 0;}

    /* Folder tree */
    #folders .node{display:flex;align-items:flex-start;gap:8px;padding:6px 0;}
    #folders .node .label{font-size:12.5px;line-height:1.2;flex:1;min-width:0;word-break:break-word;}
    #folders .node .meta{display:flex;gap:8px;align-items:center;margin-left:auto;white-space:nowrap;}
    #folders .node .counts{font-size:11px;opacity:.7;}
    #folders .node .zoomBtn{border:1px solid var(--border);background:rgba(255,255,255,.9);padding:4px 8px;border-radius:999px;cursor:pointer;font-size:12px;line-height:1;}
    #folders details{padding-left:12px;}
    #folders summary{list-style:none;cursor:pointer;}
    #folders summary::-webkit-details-marker{display:none;}

</style>
</head>
<body>
  <div id="panelToggleBtn" style="display:none;">☰ Layers</div>

  <div id="app">
    <aside id="panel" class="open">
      <div id="panelHeader">
        <h1>KML layers</h1>
        <p class="sub">Folder structure is read from the KML and shown as toggles.</p>
      </div>

      <div id="controls">
        <input id="search" placeholder="Search features…" autocomplete="off" />
        <div id="toggles">
          <label class="pill" title="Toggle satellite imagery"><input id="satToggle" type="checkbox" />Satellite</label>
          <label class="pill" title="Toggle point clustering"><input id="clusterToggle" type="checkbox" checked />Cluster points</label>
          <label class="pill" title="Toggle heatmap (points only)"><input id="heatToggle" type="checkbox" />Heatmap</label>
          <button id="debugToggle" class="pill" type="button">Debug: Off</button>
        </div>
      </div>

      <div id="foldersWrap">
        <div id="foldersTitle">
          <span>Folders (tree)</span>
          <span style="display:flex;gap:6px;align-items:center;">
            <button id="allOn" class="smallbtn" type="button">All on</button>
            <button id="allOff" class="smallbtn" type="button">All off</button>
            <button id="expandAll" class="smallbtn" type="button">Expand</button>
            <button id="collapseAll" class="smallbtn" type="button">Collapse</button>
          </span>
        </div>
        <div id="folders"></div>
      </div>

      <ul id="featureList"></ul>

      <div id="panelFooter">
        <span id="count">Loading KML…</span>
        <span style="white-space:nowrap;">Click tolerance: high</span>
      </div>
    </aside>

    <main style="position:relative;">
      <div id="map"></div>
      <div class="hint">Tip: toggle folders to hide/show features</div>

      <div id="popup" class="ol-popup" style="display:none;">
        <a href="#" id="popup-closer" class="ol-popup-closer" aria-label="Close popup">×</a>
        <div id="popup-content"></div>
      </div>

      <div id="err" class="err"></div>

      <div id="debug" class="err" style="display:none;background:rgba(245,250,255,.95);border-color:rgba(0,80,200,.25);color:rgba(0,40,120,.92);">
        <b>Debug</b>
        <div id="debugText" style="margin-top:6px;">Loading…</div>
        <div style="margin-top:8px;display:flex;gap:8px;flex-wrap:wrap;">
          <button id="fitBtn" class="smallbtn" type="button">Fit to data</button>
          <button id="showAllBtn" class="smallbtn" type="button">Show all folders</button>
          <button id="hideAllBtn" class="smallbtn" type="button">Hide all folders</button>
        </div>
      </div>

    </main>
  </div>

  <script src="https://cdn.jsdelivr.net/npm/ol@latest/dist/ol.js"></script>
  <script>
    // -------- Helpers
    function escapeHtml(s){return String(s).replaceAll('&','&amp;').replaceAll('<','&lt;').replaceAll('>','&gt;').replaceAll('"','&quot;').replaceAll("'","&#039;");}
    function getTitle(p){const t=(p.name??p.Name??p.NAME??'').toString().trim(); return t||'Feature';}
    function getDescription(p){const d=p.description??p.Description??''; if(d===null||d===undefined) return ''; return String(d).trim();}
    function sanitizeDescriptionHtml(desc){
      if(!desc) return '';
      // DOMPurify is loaded from CDN; if it fails, fall back to escaped text.
      if(typeof DOMPurify !== 'undefined'){
        return DOMPurify.sanitize(desc, {
          USE_PROFILES: { html: true },
          ALLOWED_TAGS: [
            'table','thead','tbody','tr','th','td',
            'b','strong','i','em','u','br','p','div','span',
            'ul','ol','li','a','hr'
          ],
          ALLOWED_ATTR: ['href','title','target','rel','style','class','colspan','rowspan']
        });
      }
      return escapeHtml(desc);
    }

    function fmtLatLon(coord3857){const ll=ol.proj.toLonLat(coord3857); return `${ll[1].toFixed(6)}, ${ll[0].toFixed(6)}`;}
    function showError(msg){const el=document.getElementById('err'); el.textContent=msg; el.style.display='block';}

    // -------- URL state (shareable view + toggles + enabled folders)
    function parseUrlState(){
      const params = new URLSearchParams(window.location.search);
      const z = Number(params.get('z'));
      const lon = Number(params.get('lon'));
      const lat = Number(params.get('lat'));
      const sat = params.get('sat') === '1';
      const cluster = params.get('cluster') !== '0';
      const heat = params.get('heat') === '1';
      const foldersRaw = params.get('folders') || '';
      const folders = foldersRaw ? foldersRaw.split('|').map(decodeURIComponent).filter(Boolean) : null;
      return { z, lon, lat, sat, cluster, heat, folders };
    }

    function saveUrlState(){
      try{
        const view = map.getView();
        const center = ol.proj.toLonLat(view.getCenter());
        const z = view.getZoom();
        const params = new URLSearchParams(window.location.search);
        params.set('z', String(Math.round(z*100)/100));
        params.set('lon', String(Math.round(center[0]*1000000)/1000000));
        params.set('lat', String(Math.round(center[1]*1000000)/1000000));
        params.set('sat', document.getElementById('satToggle')?.checked ? '1' : '0');
        params.set('cluster', document.getElementById('clusterToggle')?.checked ? '1' : '0');
        params.set('heat', document.getElementById('heatToggle')?.checked ? '1' : '0');
        if(typeof folderTotalCounts !== 'undefined' && folderTotalCounts.size && enabledFolders.size === folderTotalCounts.size){
          params.delete('folders');
        } else {
          const list = Array.from(enabledFolders).map(encodeURIComponent).join('|');
          params.set('folders', list);
        }
        const newUrl = window.location.pathname + '?' + params.toString();
        history.replaceState(null, '', newUrl);
      } catch(e){}
    }


    // -------- Base layers
    const osmLayer=new ol.layer.Tile({source:new ol.source.OSM(), visible:true});
    const esriLayer=new ol.layer.Tile({
      source:new ol.source.XYZ({
        url:'https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}',
        attributions:'Tiles © Esri'
      }),
      visible:false
    });

    // -------- Sources
    const pointSource=new ol.source.Vector();
    const otherSource=new ol.source.Vector();
    const clusterSource=new ol.source.Cluster({distance:40, minDistance:12, source: pointSource});

    // We'll use a single style function that can "hide" features by returning null.
    const enabledFolders = new Set(); // folder paths that are ON

    function defaultStyleForFeature(f){
      const t = f.getGeometry()?.getType?.() || '';
      if(t==='Point' || t==='MultiPoint'){
        return new ol.style.Style({
          image:new ol.style.Circle({
            radius:6,
            fill:new ol.style.Fill({color:'rgba(220,0,0,.85)'}),
            stroke:new ol.style.Stroke({color:'white', width:1})
          })
        });
      }
      return new ol.style.Style({
        stroke:new ol.style.Stroke({color:'rgba(0,80,200,.9)', width:2}),
        fill:new ol.style.Fill({color:'rgba(0,80,200,.12)'})
      });
    }

    function visibleStyle(feature, resolution){
      // For cluster wrapper feature
      const clustered = feature.get('features');
      if(Array.isArray(clustered)){
        const size = clustered.length;
        if(size===1){
          return visibleStyle(clustered[0], resolution); // defer to real feature
        }
        // Cluster visible if ANY underlying feature is visible
        const anyVisible = enabledFolders.size === 0 || clustered.some(f => enabledFolders.has(f.get('folderPath') || 'Uncategorised'));
        if(!anyVisible) return null;

        return new ol.style.Style({
          image:new ol.style.Circle({
            radius: Math.min(22, 10 + Math.log(size)*6),
            fill:new ol.style.Fill({color:'rgba(0,0,0,0.55)'}),
            stroke:new ol.style.Stroke({color:'rgba(255,255,255,0.9)', width:2})
          }),
          text:new ol.style.Text({
            text:String(size),
            fill:new ol.style.Fill({color:'white'}),
            font:'bold 12px system-ui,-apple-system,Segoe UI,Roboto,Arial,sans-serif'
          })
        });
      }

      const folder = feature.get('folderPath') || 'Uncategorised';
      if(enabledFolders.size && !enabledFolders.has(folder)) return null;

      // Preserve KML-extracted style if present
      const base = feature.get('baseStyle') || (feature.getStyle && feature.getStyle());
      if (typeof base === 'function') return base(feature, resolution);
      return base || defaultStyleForFeature(feature);
    }

    const otherLayer = new ol.layer.Vector({ source: otherSource, style: visibleStyle });
    const clusteredPointLayer = new ol.layer.Vector({ source: clusterSource, visible:true, style: visibleStyle });
    const plainPointLayer = new ol.layer.Vector({ source: pointSource, visible:false, style: visibleStyle });

    // Heatmap layer (points only). Uses pointSource (non-clustered).
    const heatmapLayer = new ol.layer.Heatmap({
      source: pointSource,
      visible: false,
      blur: 18,
      radius: 10,
      weight: function(feature){
        const w = Number(feature.get('weight'));
        return Number.isFinite(w) ? w : 1;
      }
    });

    // -------- Map
    const map=new ol.Map({
      target:'map',
      layers:[osmLayer, esriLayer, otherLayer, heatmapLayer, clusteredPointLayer, plainPointLayer],
      view:new ol.View({center: ol.proj.fromLonLat([53,32]), zoom:5})
    });

    // Apply URL state (if present)
    const urlState = parseUrlState();
    if(Number.isFinite(urlState.lon) && Number.isFinite(urlState.lat)){
      map.getView().setCenter(ol.proj.fromLonLat([urlState.lon, urlState.lat]));
    }
    if(Number.isFinite(urlState.z)){
      map.getView().setZoom(urlState.z);
    }


    function fitToAll(){
      const exts=[];
      if(pointSource.getFeatures().length) exts.push(pointSource.getExtent());
      if(otherSource.getFeatures().length) exts.push(otherSource.getExtent());
      if(!exts.length) return;
      let extent=exts[0].slice();
      for(let i=1;i<exts.length;i++) ol.extent.extend(extent, exts[i]);
      map.getView().fit(extent, {padding:[40,40,40,40], maxZoom:14});
    }

    // -------- Read folder structure from KML XML
    // This reads <Folder><name>…</name> nesting and assigns each <Placemark> a folder "path" like "Parent / Child".
    // Matching placemarks to OpenLayers features:
    // - If Placemark has an "id" attribute and OL feature has an id, we match by id.
    // - Otherwise we fall back to document order (works for most KML exports, but not guaranteed).
    function readPlacemarkFolderMeta(kmlText){
      const parser = new DOMParser();
      const xml = parser.parseFromString(kmlText, 'application/xml');

      // Detect parse errors
      const perr = xml.getElementsByTagName('parsererror');
      if(perr && perr.length) throw new Error('KML XML parse error.');

      const metaById = new Map();
      const metaInOrder = [];

      function elText(el, tag){
        const n = el.getElementsByTagName(tag)[0];
        return n ? (n.textContent || '').trim() : '';
      }

      function walk(node, path){
        // Only consider element nodes
        for(const child of node.children){
          const local = child.localName;

          if(local === 'Folder'){
            const fname = elText(child, 'name') || 'Folder';
            walk(child, path.concat([fname]));
          } else if(local === 'Placemark'){
            const pname = elText(child, 'name') || '';
            const pid = child.getAttribute('id') || '';
            const folderPath = path.length ? path.join(' / ') : 'Uncategorised';
            const m = { id: pid, name: pname, folderPath };

            if(pid) metaById.set(pid, m);
            metaInOrder.push(m);
          } else {
            // Recurse into Document or other containers
            walk(child, path);
          }
        }
      }

      // Start at Document if present
      const docs = xml.getElementsByTagNameNS('*','Document');
      if(docs && docs.length){
        walk(docs[0], []);
      } else {
        walk(xml.documentElement, []);
      }
      return { metaById, metaInOrder };
    }

    // -------- Load KML and build features + folders UI
    const KML_URL = 'Iran_new.kml?v=' + Date.now();

    (async ()=>{
      try{
        const res = await fetch(KML_URL, {cache:'no-store'});
        if(!res.ok) throw new Error(`HTTP ${res.status} ${res.statusText} fetching ${KML_URL}`);
        const text = await res.text();

        if(text.startsWith('version https://git-lfs.github.com/spec/v1')){
          throw new Error('Your KML is being served as a Git LFS pointer, not real XML. Remove Git LFS for .kml and commit the actual file.');
        }

        const { metaById, metaInOrder } = readPlacemarkFolderMeta(text);

        const kmlFormat = new ol.format.KML({extractStyles:true});
        const features = kmlFormat.readFeatures(text, { featureProjection: map.getView().getProjection() });

        if(!features.length) throw new Error('KML loaded, but 0 features were parsed.');

        setDebug(`Fetched ${text.length} chars from ${KML_URL} • Parsed ${features.length} feature(s)`);

        // Assign folderPath + preserve base style
        // Try match by id if possible
        let matchedById = 0;
        for(const f of features){
          // Preserve the extracted style (if any) because we use a style function now
          if(f.getStyle && f.getStyle()){
            f.set('baseStyle', f.getStyle());
            f.setStyle(null); // allow layer style function to drive rendering
          }

          const fid = (typeof f.getId === 'function') ? f.getId() : null;
          if(fid && metaById.has(String(fid))){
            const m = metaById.get(String(fid));
            f.set('folderPath', m.folderPath);
            matchedById++;
          }
        }

        // Fallback: assign by document order for any still missing
        if(matchedById === 0){
          // Assign in order (best-effort)
          for(let i=0;i<features.length;i++){
            const f = features[i];
            if(f.get('folderPath')) continue;
            const m = metaInOrder[i];
            f.set('folderPath', (m && m.folderPath) ? m.folderPath : 'Uncategorised');
          }
        } else {
          // Fill any leftover without matches
          for(const f of features){
            if(!f.get('folderPath')) f.set('folderPath', 'Uncategorised');
          }
        }

        // Populate sources
        for(const f of features){
          const g=f.getGeometry(); if(!g) continue;
          const t=g.getType();
          if(t==='Point' || t==='MultiPoint') pointSource.addFeature(f);
          else otherSource.addFeature(f);
        }

        // Build folder set (default ON)
        const all = [...pointSource.getFeatures(), ...otherSource.getFeatures()];
        const folderCounts = new Map();
        for(const f of all){
          const p = f.get('folderPath') || 'Uncategorised';
          folderCounts.set(p, (folderCounts.get(p) || 0) + 1);
        }
        for(const k of folderCounts.keys()) enabledFolders.add(k);

        if(urlState && Array.isArray(urlState.folders)){
          enabledFolders.clear();
          for(const f of urlState.folders){ enabledFolders.add(f); }
        }

        computeFolderExtents();
        buildFolderTreeUI(folderCounts);
        buildSidebar(); // uses enabledFolders to filter list
        fitToAll();
        updateFoldersInView();

        const pe = pointSource.getExtent();
        const oe = otherSource.getExtent();
        const sample = features[0];
        const sc = sample?.getGeometry?.() ? ol.extent.getCenter(sample.getGeometry().getExtent()) : null;
        setDebug(`Fetched ${text.length} chars from ${KML_URL} • Parsed ${features.length} feature(s) • Points: ${pointSource.getFeatures().length} • Other: ${otherSource.getFeatures().length}\nPoint extent: ${extentToStr(pe)}\nOther extent: ${extentToStr(oe)}\nSample center (3857): ${sc ? sc.map(v=>v.toFixed(2)).join(', ') : '(none)'}`);

        document.getElementById('count').textContent =
          `${pointSource.getFeatures().length} point(s), ${otherSource.getFeatures().length} other feature(s)`;

        // Ensure initial render with enabled folders
        otherLayer.changed(); clusteredPointLayer.changed(); plainPointLayer.changed(); heatmapLayer.changed();

      }catch(err){
        document.getElementById('count').textContent = 'Load error';
        showError(String(err));
        console.error(err);
      }
    })();

    // -------- Folder UI (tree + zoom-to-folder) + in-view counts
    const foldersEl = document.getElementById('folders');

    // Build a tree from leaf folder paths like "A / B / C"
    function makeTree(pathsWithCounts){
      const root = { name: 'root', path: '', children: new Map(), leafPaths: [] };

      for(const [path, totalCount] of pathsWithCounts.entries()){
        const parts = path.split(' / ');
        let node = root;
        let curPath = '';
        for(const part of parts){
          curPath = curPath ? (curPath + ' / ' + part) : part;
          if(!node.children.has(part)){
            node.children.set(part, { name: part, path: curPath, children: new Map(), leafPaths: [] });
          }
          node = node.children.get(part);
        }
        node.leafPaths.push(path); // leaf is the full path itself
      }
      return root;
    }

    // Map: folderPath -> extent (for zoom). We'll also aggregate for parent nodes.
    const folderExtent = new Map(); // path -> extent in map projection
    function extendExtent(a, b){
      if(!b) return a;
      if(!a) return b.slice();
      const out = a.slice();
      if(b[0] < out[0]) out[0] = b[0];
      if(b[1] < out[1]) out[1] = b[1];
      if(b[2] > out[2]) out[2] = b[2];
      if(b[3] > out[3]) out[3] = b[3];
      return out;
    }

    function computeFolderExtents(){
      folderExtent.clear();
      const all = [...pointSource.getFeatures(), ...otherSource.getFeatures()];
      for(const f of all){
        const folder = f.get('folderPath') || 'Uncategorised';
        const g = f.getGeometry();
        if(!g) continue;
        const ext = g.getExtent();
        folderExtent.set(folder, extendExtent(folderExtent.get(folder), ext));
      }
      // Aggregate to parents
      for(const key of Array.from(folderExtent.keys())){
        const parts = key.split(' / ');
        for(let i=1;i<parts.length;i++){
          const parent = parts.slice(0,i).join(' / ');
          folderExtent.set(parent, extendExtent(folderExtent.get(parent), folderExtent.get(key)));
        }
      }
    }

    // Utilities for enabled state across a tree
    function getDescendantLeafPaths(node){
      let leaves = [];
      if(node.leafPaths?.length) leaves = leaves.concat(node.leafPaths);
      for(const child of node.children.values()){
        leaves = leaves.concat(getDescendantLeafPaths(child));
      }
      return leaves;
    }

    function setEnabledForLeaves(leaves, enabled){
      if(enabled){
        for(const p of leaves) enabledFolders.add(p);
      } else {
        for(const p of leaves) enabledFolders.delete(p);
      }
    }

    function computeNodeCheckState(leaves){
      let on = 0;
      for(const p of leaves){
        if(enabledFolders.has(p)) on++;
      }
      if(on === 0) return 'off';
      if(on === leaves.length) return 'on';
      return 'partial';
    }

    function zoomToPath(path){
      const ext = folderExtent.get(path);
      if(!ext) return;
      map.getView().fit(ext, { padding:[60,60,60,60], maxZoom: 15, duration: 350 });
    }

    // Render tree using <details> for collapsible folders
    function renderNode(node, inViewCounts){
      const leaves = getDescendantLeafPaths(node);
      const state = computeNodeCheckState(leaves);

      // in-view aggregation
      let inView = 0;
      for(const p of leaves) inView += (inViewCounts.get(p) || 0);

      const total = leaves.reduce((acc, p) => acc + (folderTotalCounts.get(p) || 0), 0);

      const wrapper = document.createElement('details');
      wrapper.open = true;

      const summary = document.createElement('summary');

      const row = document.createElement('div');
      row.className = 'node';
      row.style.opacity = inView ? '1' : '0.35';

      const cb = document.createElement('input');
      cb.type = 'checkbox';
      cb.checked = (state === 'on');
      cb.indeterminate = (state === 'partial');
      cb.addEventListener('click', (e)=> e.stopPropagation());
      cb.addEventListener('change', (e)=>{
        e.stopPropagation();
        setEnabledForLeaves(leaves, cb.checked);
        otherLayer.changed(); clusteredPointLayer.changed(); plainPointLayer.changed(); heatmapLayer.changed(); heatmapLayer.changed();
        renderList(document.getElementById('search').value);
        overlay.setPosition(undefined); container.style.display='none';
        saveUrlState();
        updateFoldersInView();
      });

      const label = document.createElement('div');
      label.className = 'label';
      label.textContent = node.name;

      const meta = document.createElement('div');
      meta.className = 'meta';

      const counts = document.createElement('div');
      counts.className = 'counts';
      counts.textContent = `${total} total • ${inView} in view`;

      const zoomBtn = document.createElement('button');
      zoomBtn.className = 'zoomBtn';
      zoomBtn.type = 'button';
      zoomBtn.textContent = 'Fit';
      zoomBtn.title = 'Zoom to this folder';
      zoomBtn.addEventListener('click', (e)=>{
        e.preventDefault();
        e.stopPropagation();
        zoomToPath(node.path);
      });

      meta.appendChild(counts);
      meta.appendChild(zoomBtn);

      row.appendChild(cb);
      row.appendChild(label);
      row.appendChild(meta);

      summary.appendChild(row);
      wrapper.appendChild(summary);

      // Children
      const kids = document.createElement('div');
      for(const child of Array.from(node.children.values()).sort((a,b)=>a.name.localeCompare(b.name))){
        kids.appendChild(renderNode(child, inViewCounts));
      }
      wrapper.appendChild(kids);
      return wrapper;
    }

    // Store totals (leaf path -> count)
    const folderTotalCounts = new Map();

    function buildFolderTreeUI(folderCounts){
      foldersEl.innerHTML = '';
      folderTotalCounts.clear();
      for(const [k,v] of folderCounts.entries()) folderTotalCounts.set(k,v);

      const root = makeTree(folderCounts);
      const inViewCounts = computeInViewCounts();

      // Render top-level nodes
      for(const child of Array.from(root.children.values()).sort((a,b)=>a.name.localeCompare(b.name))){
        foldersEl.appendChild(renderNode(child, inViewCounts));
      }
    }

    function computeInViewCounts(){
      const extent = map.getView().calculateExtent(map.getSize());
      const inViewCounts = new Map();

      pointSource.forEachFeatureIntersectingExtent(extent, f => {
        const folder = f.get('folderPath') || 'Uncategorised';
        inViewCounts.set(folder, (inViewCounts.get(folder) || 0) + 1);
      });

      otherSource.forEachFeatureIntersectingExtent(extent, f => {
        const folder = f.get('folderPath') || 'Uncategorised';
        inViewCounts.set(folder, (inViewCounts.get(folder) || 0) + 1);
      });

      return inViewCounts;
    }

    function updateFoldersInView(){
      const wrap = document.getElementById('foldersWrap');
      const scrollTop = wrap ? wrap.scrollTop : 0;
      buildFolderTreeUI(new Map(folderTotalCounts));
      if(wrap) wrap.scrollTop = scrollTop;
      saveUrlState();
    }

    document.getElementById('allOn').onclick = ()=>{
      for(const k of folderTotalCounts.keys()) enabledFolders.add(k);
      otherLayer.changed(); clusteredPointLayer.changed(); plainPointLayer.changed(); heatmapLayer.changed(); heatmapLayer.changed();
      renderList(document.getElementById('search').value);
      saveUrlState();
      updateFoldersInView();
    };
    document.getElementById('allOff').onclick = ()=>{
      enabledFolders.clear();
      otherLayer.changed(); clusteredPointLayer.changed(); plainPointLayer.changed(); heatmapLayer.changed(); heatmapLayer.changed();
      renderList(document.getElementById('search').value);
      overlay.setPosition(undefined); container.style.display='none';
      saveUrlState();
      updateFoldersInView();
    };

    // Expand/collapse all folder nodes
    document.getElementById('expandAll').onclick = ()=>{
      document.querySelectorAll('#folders details').forEach(d => d.open = true);
    };
    document.getElementById('collapseAll').onclick = ()=>{
      document.querySelectorAll('#folders details').forEach(d => d.open = false);
      // Keep the user from "losing" the list entirely: ensure top-level nodes remain visible in collapsed state
    };


    map.on('moveend', updateFoldersInView);

    // -------- Sidebar list + search (respects folder toggles)
    const listEl=document.getElementById('featureList');
    const searchEl=document.getElementById('search');
    let allFeatures=[];

    function buildSidebar(){
      allFeatures=[...pointSource.getFeatures(), ...otherSource.getFeatures()];
      allFeatures.sort((a,b)=> getTitle(a.getProperties()).localeCompare(getTitle(b.getProperties())));
      renderList('');
    }

    function renderList(filter){
      const f=filter.trim().toLowerCase();
      listEl.innerHTML='';

      const visible = allFeatures.filter(feat => enabledFolders.has(feat.get('folderPath') || 'Uncategorised'));

      const filtered = f ? visible.filter(feat=>{
        const p=feat.getProperties();
        return getTitle(p).toLowerCase().includes(f) || getDescription(p).toLowerCase().includes(f);
      }) : visible;

      for(const feat of filtered){
        const p=feat.getProperties();
        const name=getTitle(p);
        const desc=getDescription(p);
        const folder = feat.get('folderPath') || 'Uncategorised';

        const li=document.createElement('li');
        li.className='item';
        li.innerHTML = `<div class="name">${escapeHtml(name)}</div>
          <div class="meta">${escapeHtml(folder)} • ${escapeHtml(desc ? desc.slice(0,90) : 'No description')}${desc && desc.length>90 ? ' …' : ''}</div>`;
        li.addEventListener('click', ()=>{
          const g=feat.getGeometry(); if(!g) return;
          const extent=g.getExtent();
          map.getView().fit(extent, {padding:[60,60,60,60], maxZoom:15, duration:300});
          const center=ol.extent.getCenter(extent);
          openPopupForFeatures([feat], center, 0);
          closePanelOnMobile();
        });
        listEl.appendChild(li);
      }

      document.getElementById('count').textContent =
        `${filtered.length} shown / ${visible.length} visible / ${allFeatures.length} total`;
    }

    searchEl.addEventListener('input', (e)=> renderList(e.target.value));

    // -------- Popup + overlap nav (only for visible features)
    const container=document.getElementById('popup');
    const content=document.getElementById('popup-content');
    const closer=document.getElementById('popup-closer');
    const overlay=new ol.Overlay({element:container, autoPan:{animation:{duration:250}}});
    map.addOverlay(overlay);
    closer.onclick=(evt)=>{evt.preventDefault(); overlay.setPosition(undefined); container.style.display='none'; closer.blur(); return false;};

    function buildPropsTable(props){
      const ignored=new Set(['geometry','styleUrl','style','name','Name','NAME','description','Description','folderPath','baseStyle']);
      let rows='';
      for(const [k,v] of Object.entries(props)){
        if(ignored.has(k)) continue;
        if(v===null||v===undefined) continue;
        const vs=String(v).trim(); if(!vs) continue;
        rows += `<tr><td style="padding:4px 10px 4px 0;vertical-align:top;opacity:.75;">${escapeHtml(k)}</td>
                 <td style="padding:4px 0;vertical-align:top;">${escapeHtml(vs)}</td></tr>`;
      }
      return rows ? `<table style="border-collapse:collapse;width:100%;">${rows}</table>` : '';
    }

    function openPopupForFeatures(featureList, coordinate, idx){
      const i=Math.max(0, Math.min(idx, featureList.length-1));
      const feat=featureList[i];
      const props=feat.getProperties();
      const title=getTitle(props);
      const desc=getDescription(props);
      const descHtml = sanitizeDescriptionHtml(desc);
      const folder = feat.get('folderPath') || 'Uncategorised';
      const table=buildPropsTable(props);

      const coordLine=`<div style="margin:6px 0 10px;opacity:.75;">Folder: ${escapeHtml(folder)}<br/>Location: ${escapeHtml(fmtLatLon(coordinate))}</div>`;
      const nav = featureList.length>1 ? `
        <div class="popup-nav">
          <button class="btn" id="prevBtn" ${i===0?'disabled':''}>← Prev</button>
          <span>${i+1} / ${featureList.length}</span>
          <button class="btn" id="nextBtn" ${i===featureList.length-1?'disabled':''}>Next →</button>
        </div>` : '';

      content.innerHTML = `
        <div class="popup-title">${escapeHtml(title)}</div>
        ${descHtml ? `<div class="descHtml">${descHtml}</div>` : ''}
        ${coordLine}
        ${table || `<div style="opacity:.75;">No attributes found</div>`}
        ${nav}
      `;

      overlay.setPosition(coordinate);
      container.style.display='block';

      if(featureList.length>1){
        const prevBtn=document.getElementById('prevBtn');
        const nextBtn=document.getElementById('nextBtn');
        if(prevBtn) prevBtn.onclick=()=> openPopupForFeatures(featureList, coordinate, i-1);
        if(nextBtn) nextBtn.onclick=()=> openPopupForFeatures(featureList, coordinate, i+1);
      }
    }

    map.on('singleclick', (evt)=>{
      const hit=[];
      map.forEachFeatureAtPixel(evt.pixel, (feat)=>{
        const clustered=feat.get('features');
        if(Array.isArray(clustered)) clustered.forEach(f=> hit.push(f));
        else hit.push(feat);
      }, {hitTolerance: 12});

      // Filter to visible features only
      const visibleHit = hit.filter(f => enabledFolders.has(f.get('folderPath') || 'Uncategorised'));

      if(!visibleHit.length){overlay.setPosition(undefined); container.style.display='none'; return;}

      const uniq=[]; const seen=new Set();
      for(const f of visibleHit){const id=f.ol_uid; if(seen.has(id)) continue; seen.add(id); uniq.push(f);}
      openPopupForFeatures(uniq, evt.coordinate, 0);
    });

    // -------- Toggles
    document.getElementById('satToggle').addEventListener('change', (e)=>{
      const on=e.target.checked; esriLayer.setVisible(on); osmLayer.setVisible(!on);
      saveUrlState();
    });
    document.getElementById('clusterToggle').addEventListener('change', (e)=>{
      const on=e.target.checked; clusteredPointLayer.setVisible(on); plainPointLayer.setVisible(!on);
    });
    document.getElementById('heatToggle').addEventListener('change', (e)=>{
      const on = e.target.checked;
      heatmapLayer.setVisible(on);
      if(on){
        document.getElementById('clusterToggle').checked = false;
        clusteredPointLayer.setVisible(false);
        plainPointLayer.setVisible(true);
      } else {
        const cOn = document.getElementById('clusterToggle').checked;
        clusteredPointLayer.setVisible(cOn);
        plainPointLayer.setVisible(!cOn);
      }
      saveUrlState();
    });


    

    // Initialise toggle states from URL (after listeners are bound)
    if(typeof urlState !== 'undefined'){
      document.getElementById('satToggle').checked = !!urlState.sat;
      esriLayer.setVisible(!!urlState.sat);
      osmLayer.setVisible(!urlState.sat);

      document.getElementById('heatToggle').checked = !!urlState.heat;
      if(urlState.heat){
        heatmapLayer.setVisible(true);
        document.getElementById('clusterToggle').checked = false;
        clusteredPointLayer.setVisible(false);
        plainPointLayer.setVisible(true);
      } else {
        document.getElementById('clusterToggle').checked = (urlState.cluster !== false);
        clusteredPointLayer.setVisible(document.getElementById('clusterToggle').checked);
        plainPointLayer.setVisible(!document.getElementById('clusterToggle').checked);
      }
    }

// -------- Mobile panel toggle
    const panel=document.getElementById('panel');
    const panelBtn=document.getElementById('panelToggleBtn');
    function isMobile(){return window.matchMedia('(max-width: 820px)').matches;}
    function syncPanelUI(){ if(isMobile()){panelBtn.style.display='block'; panel.classList.remove('open');} else {panelBtn.style.display='none'; panel.classList.add('open');} }
    function closePanelOnMobile(){ if(isMobile()) panel.classList.remove('open'); }
    panelBtn.addEventListener('click', ()=> panel.classList.toggle('open'));
    window.addEventListener('resize', syncPanelUI);
    syncPanelUI();
  
    
    // -------- Dynamic folder counts based on zoom
    function updateFoldersInView(){
      const extent = map.getView().calculateExtent(map.getSize());
      const inViewCounts = new Map();

      pointSource.forEachFeatureIntersectingExtent(extent, f => {
        const folder = f.get('folderPath') || 'Uncategorised';
        inViewCounts.set(folder, (inViewCounts.get(folder) || 0) + 1);
      });

      otherSource.forEachFeatureIntersectingExtent(extent, f => {
        const folder = f.get('folderPath') || 'Uncategorised';
        inViewCounts.set(folder, (inViewCounts.get(folder) || 0) + 1);
      });

      document.querySelectorAll('#folders .folder').forEach(row => {
        const name = row.querySelector('.name')?.textContent?.trim();
        const label = row.querySelector('.inView');
        const count = inViewCounts.get(name) || 0;

        if(label) label.textContent = `${count} in view`;
        row.style.opacity = count ? '1' : '0.35';
      });
    }

    map.on('moveend', updateFoldersInView);

    // -------- Debug helpers
    function extentToStr(ext){
      if(!ext || ext.length !== 4) return '(none)';
      return ext.map(v => Number.isFinite(v) ? v.toFixed(2) : String(v)).join(', ');
    }
    function setDebug(msg){
      const el = document.getElementById('debugText');
      if(el) el.textContent = msg;
    }

    // Wire debug buttons
    document.getElementById('fitBtn').onclick = ()=> { try{ fitToAll();
        updateFoldersInView(); }catch(e){} };
    document.getElementById('showAllBtn').onclick = ()=> {
      // turn on all folders that exist
      const cbs = document.querySelectorAll('#folders input[type=checkbox]');
      cbs.forEach(cb => cb.checked = true);
      // rebuild enabledFolders from UI
      enabledFolders.clear();
      document.querySelectorAll('#folders .folder').forEach(row => {
        const name = row.querySelector('.name')?.textContent?.trim();
        const cb = row.querySelector('input[type=checkbox]');
        if(name && cb && cb.checked) enabledFolders.add(name);
      });
      otherLayer.changed(); clusteredPointLayer.changed(); plainPointLayer.changed(); heatmapLayer.changed();
      renderList(document.getElementById('search').value);
    };
    document.getElementById('hideAllBtn').onclick = ()=> {
      enabledFolders.clear();
      document.querySelectorAll('#folders input[type=checkbox]').forEach(cb => cb.checked = false);
      otherLayer.changed(); clusteredPointLayer.changed(); plainPointLayer.changed(); heatmapLayer.changed();
      renderList(document.getElementById('search').value);
      overlay.setPosition(undefined); container.style.display='none';
    };


    // -------- Debug toggle
    const debugPanel = document.getElementById('debug');
    const debugToggleBtn = document.getElementById('debugToggle');
    let debugVisible = false;
    debugToggleBtn.textContent = 'Debug: Off';

    debugToggleBtn.onclick = () => {
      debugVisible = !debugVisible;
      debugPanel.style.display = debugVisible ? 'block' : 'none';
      debugToggleBtn.textContent = debugVisible ? 'Debug: On' : 'Debug: Off';
    };

</script>
</body>
</html>

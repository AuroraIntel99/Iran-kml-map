<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>OpenLayers KML Map (Folder Toggles)</title>
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/ol@10.8.0/ol.css" />
  <script src="https://cdn.jsdelivr.net/npm/dompurify@3.1.6/dist/purify.min.js"></script>
  <style>
    :root{
      --panel-w:340px;--border:rgba(0,0,0,.15);--bg:rgba(255,255,255,.92);
      --shadow:0 8px 24px rgba(0,0,0,.18);--radius:10px;
      --font:system-ui,-apple-system,Segoe UI,Roboto,Arial,sans-serif;
    }
    html,body{height:100%;margin:0;padding:0;font-family:var(--font);}
    #app{height:100%;width:100%;display:grid;grid-template-columns:var(--panel-w) 1fr;}
    #map{width:100%;height:100%;}
    #panel{background:var(--bg);border-right:1px solid var(--border);overflow:hidden;display:grid;grid-template-rows:auto auto auto 1fr auto;}
    #panelHeader{padding:12px 12px 10px;border-bottom:1px solid var(--border);}
    #panelHeader h1{margin:0 0 6px;font-size:15px;font-weight:800;}
    #panelHeader .sub{margin:0;font-size:12px;opacity:.75;line-height:1.3;}
    #controls{padding:10px 12px;border-bottom:1px solid var(--border);display:grid;gap:8px;}
    #search{width:100%;box-sizing:border-box;padding:9px 10px;border-radius:10px;border:1px solid var(--border);outline:none;font-size:13px;background:rgba(255,255,255,.95);}
    #toggles{display:flex;gap:8px;align-items:center;flex-wrap:wrap;font-size:12px;opacity:.9;}
    .pill{display:inline-flex;align-items:center;gap:6px;padding:6px 10px;border:1px solid var(--border);border-radius:999px;background:rgba(255,255,255,.85);cursor:pointer;user-select:none;}
    .pill input{margin:0;}
    #foldersWrap{padding:10px 12px;border-bottom:1px solid var(--border);overflow:auto;max-height:34vh;}
    #foldersTitle{display:flex;justify-content:space-between;gap:10px;align-items:center;margin:0 0 8px 0;font-size:13px;font-weight:750;}
    .smallbtn{border:1px solid var(--border);background:rgba(255,255,255,.9);padding:5px 8px;border-radius:999px;cursor:pointer;font-size:12px;}
    .folder{display:flex;align-items:flex-start;gap:8px;padding:6px 0;}
    .folder input{margin-top:2px;}
    .folder .name{font-size:12.5px;line-height:1.2;}
    .folder .count{font-size:12px;opacity:.7;margin-left:auto;white-space:nowrap;}
    #featureList{overflow:auto;padding:0;margin:0;list-style:none;}
    .item{padding:10px 12px;border-bottom:1px solid rgba(0,0,0,.06);cursor:pointer;display:grid;gap:4px;}
    .item:hover{background:rgba(0,0,0,.035);}
    .item .name{font-size:13px;font-weight:650;}
    .item .meta{font-size:12px;opacity:.75;}
    #panelFooter{padding:10px 12px;border-top:1px solid var(--border);font-size:12px;opacity:.75;display:flex;justify-content:space-between;gap:10px;align-items:center;flex-wrap:wrap;}
    @media (max-width:820px){
      #app{grid-template-columns:1fr;}
      #panel{position:absolute;z-index:10;width:min(92vw,var(--panel-w));height:calc(100% - 20px);left:10px;top:10px;border:1px solid var(--border);border-radius:var(--radius);box-shadow:var(--shadow);transform:translateX(calc(-100% - 16px));transition:transform .25s ease;}
      #panel.open{transform:translateX(0);}
      #panelToggleBtn{position:absolute;z-index:11;left:10px;top:10px;background:var(--bg);border:1px solid var(--border);border-radius:999px;box-shadow:var(--shadow);padding:8px 10px;font-size:13px;cursor:pointer;}
    }
    .ol-popup{position:absolute;background:#fff;padding:12px 12px 10px;border-radius:10px;border:1px solid rgba(0,0,0,.25);bottom:12px;left:-50px;min-width:240px;max-width:min(520px,calc(100vw - 24px));box-shadow:var(--shadow);font-size:14px;line-height:1.35;}
    .ol-popup-closer{text-decoration:none;position:absolute;top:6px;right:8px;font-size:18px;color:rgba(0,0,0,.55);}
    .ol-popup-closer:hover{color:rgba(0,0,0,.85);}
    .popup-title{font-weight:800;margin:0 70px 6px 0;font-size:15px;}
    .popup-nav{display:flex;gap:8px;align-items:center;margin:8px 0 0;font-size:12px;opacity:.9;}
    .btn{border:1px solid var(--border);background:rgba(255,255,255,.9);padding:6px 10px;border-radius:999px;cursor:pointer;user-select:none;}
    .btn:disabled{opacity:.45;cursor:default;}
    .hint{position:absolute;top:10px;right:10px;background:var(--bg);border:1px solid var(--border);padding:8px 10px;border-radius:10px;font-size:12px;box-shadow:var(--shadow);}
    .err{position:absolute;left:10px;bottom:10px;background:rgba(255,245,245,.95);border:1px solid rgba(180,0,0,.25);color:rgba(120,0,0,.9);padding:10px 12px;border-radius:10px;font-size:12px;box-shadow:var(--shadow);max-width:min(760px,calc(100vw - 24px));display:none;white-space:pre-wrap;}
  
    /* Popup HTML description styling */
    #popup-content table{border-collapse:collapse;width:100%;margin:6px 0 8px 0;font-size:12.5px;}
    #popup-content th,#popup-content td{border:1px solid rgba(0,0,0,.15);padding:4px 6px;vertical-align:top;}
    #popup-content th{background:rgba(0,0,0,.04);font-weight:700;}
    #popup-content a{color:inherit;text-decoration:underline;}
    #popup-content .descHtml{margin:0 0 8px 0;}

    
    /* Folder icons + twisty indicators */
    #folders summary{display:block;}
    #folders .twisty{display:inline-block;width:16px;opacity:.75;transform-origin:center;transition:transform .12s ease;}
    #folders details[open] > summary .twisty{transform:rotate(90deg);}
    #folders .twisty::before{content:"â–¸";}
    #folders .folderIcon{display:inline-block;width:18px;text-align:center;opacity:.9;}
    #folders .folderIcon::before{content:"ðŸ“";}
    #folders details[open] > summary .folderIcon::before{content:"ðŸ“‚";}

    /* Folder tree */
    #folders .node{display:flex;align-items:flex-start;gap:8px;padding:6px 0;}
    #folders .node .label{font-size:12.5px;line-height:1.2;flex:1;min-width:0;word-break:break-word;}
    #folders .node .meta{display:flex;gap:8px;align-items:center;margin-left:auto;white-space:nowrap;}
    #folders .node .counts{font-size:11px;opacity:.7;}
    #folders .node .zoomBtn{border:1px solid var(--border);background:rgba(255,255,255,.9);padding:4px 8px;border-radius:999px;cursor:pointer;font-size:12px;line-height:1;}
    #folders details{padding-left:12px;}
    #folders summary{list-style:none;cursor:pointer;}
    #folders summary::-webkit-details-marker{display:none;}

</style>
</head>
<body>

<script>
(function(){
  function byId(id){ return document.getElementById(id); }
  function appendDebug(msg){
    try{
      var d = byId('debugText') || byId('debug') || byId('err');
      if(!d) return;
      if(d.id === 'debugText'){
        d.textContent = (d.textContent && d.textContent !== 'Loadingâ€¦') ? (d.textContent + "\n" + msg) : msg;
      } else {
        d.textContent = (d.textContent ? (d.textContent + "\n" + msg) : msg);
      }
      var debugPanel = byId('debug');
      if(debugPanel) debugPanel.style.display = 'block';
      var err = byId('err');
      if(err){ err.style.display = 'block'; }
    }catch(e){}
  }
  window.__appendDebug = appendDebug;
  window.addEventListener('error', function(ev){
    appendDebug("JS ERROR: " + (ev.message || ev.error || 'unknown') + (ev.filename ? (" @ " + ev.filename + ":" + ev.lineno) : ""));
  });
  window.addEventListener('unhandledrejection', function(ev){
    appendDebug("PROMISE REJECTION: " + (ev.reason && (ev.reason.message || ev.reason) ? (ev.reason.message || ev.reason) : String(ev.reason)));
  });
  // Also detect OL missing after a short delay
  setTimeout(function(){
    if(typeof window.ol === 'undefined'){
      appendDebug("OpenLayers (window.ol) is undefined. CDN blocked or script path wrong.");
    }
  }, 2000);
})();
</script>
<noscript><div style="padding:10px;margin:10px;border:1px solid #c00;border-radius:10px;background:#fff0f0;color:#800;">JavaScript is disabled â€” the map cannot load.</div></noscript>

  <div id="panelToggleBtn" style="display:none;">â˜° Layers</div>

  <div id="app">
    <aside id="panel" class="open">
      <div id="panelHeader">
        <h1>KML layers</h1>
        <p class="sub">Folder structure is read from the KML and shown as toggles.</p>
      </div>

      <div id="controls">
        <input id="search" placeholder="Search featuresâ€¦" autocomplete="off" />

        <div style="display:flex; gap:8px; align-items:center;">
          <input id="coordSearch" placeholder="Go to coordinates (lat, lon or lon, lat)â€¦" autocomplete="off"
                 style="flex:1;box-sizing:border-box;padding:9px 10px;border-radius:10px;border:1px solid var(--border);outline:none;font-size:13px;background:rgba(255,255,255,.95);" />
          <button id="coordGo" class="smallbtn" type="button" style="padding:8px 10px;">Go</button>
        </div>

        <div id="toggles">
          <label class="pill" title="Toggle satellite imagery"><input id="satToggle" type="checkbox" />Satellite</label>
          <label class="pill" title="Toggle point clustering"><input id="clusterToggle" type="checkbox" checked />Cluster points</label>
          <label class="pill" title="Toggle heatmap (points only)"><input id="heatToggle" type="checkbox" />Heatmap</label>
          <button id="debugToggle" class="pill" type="button">Debug: Off</button>
        </div>
      </div>

      <div id="foldersWrap">
        <div id="foldersTitle">
          <span>Folders (tree)</span>
          <span style="display:flex;gap:6px;align-items:center;">
            <button id="allOn" class="smallbtn" type="button">All on</button>
            <button id="allOff" class="smallbtn" type="button">All off</button>
            <button id="expandAll" class="smallbtn" type="button">Expand</button>
            <button id="collapseAll" class="smallbtn" type="button">Collapse</button>
          </span>
        </div>
        <div id="folders"></div>
      </div>

      <ul id="featureList"></ul>

      <div id="panelFooter">
        <span id="count">Loading KMLâ€¦</span>
        <span style="white-space:nowrap;">Click tolerance: high</span>
      </div>
    </aside>

    <main style="position:relative;">
      <div id="map"></div>
      <div class="hint">Tip: toggle folders to hide/show features</div>

      <div id="popup" class="ol-popup" style="display:none;">
        <a href="#" id="popup-closer" class="ol-popup-closer" aria-label="Close popup">Ã—</a>
        <div id="popup-content"></div>
      </div>

      <div id="err" class="err"></div>

      <div id="debug" class="err" style="display:block;background:rgba(245,250,255,.95);border-color:rgba(0,80,200,.25);color:rgba(0,40,120,.92);">
        <b>Debug</b>
        <div id="debugText" style="margin-top:6px;">Loadingâ€¦</div>
        <div style="margin-top:8px;display:flex;gap:8px;flex-wrap:wrap;">
          <button id="fitBtn" class="smallbtn" type="button">Fit to data</button>
          <button id="showAllBtn" class="smallbtn" type="button">Show all folders</button>
          <button id="hideAllBtn" class="smallbtn" type="button">Hide all folders</button>
        </div>
      </div>

    </main>
  </div>

  <script src="https://cdn.jsdelivr.net/npm/ol@10.8.0/dist/ol.js"></script>
  <script>
    if(typeof ol==='undefined'){document.getElementById('err')?.setAttribute('style','display:block');document.getElementById('err').textContent='OpenLayers failed to load from CDN. Check script tag / network.';}

    // -------- Helpers
    function escapeHtml(s){return String(s).replaceAll('&','&amp;').replaceAll('<','&lt;').replaceAll('>','&gt;').replaceAll('"','&quot;').replaceAll("'","&#039;");}
    function getTitle(p){const t=(p.name??p.Name??p.NAME??'').toString().trim(); return cleanTextEncoding(t)||'Feature';}
    function getDescription(p){const d=p.description??p.Description??''; if(d===null||d===undefined) return ''; return cleanTextEncoding(String(d).trim());}
    function cleanTextEncoding(s){
      if(s === null || s === undefined) return '';
      let t = String(s);

      // 1) Try to reverse common UTF-8->Latin1 mojibake (e.g., "Ã‚", "Ãƒ", "Ã¢â‚¬â€œ")
      // If the text looks like mojibake, attempt a Latin1->UTF8 fix.
      if(/[ÃƒÃ‚Ã¢â‚¬]/.test(t)){
        try{
          // This converts a string that was decoded as Latin-1 into proper UTF-8.
          // (escape encodes bytes 0x00-0xFF; decodeURIComponent interprets them as UTF-8)
          const fixed = decodeURIComponent(escape(t));
          // Only accept if it reduces mojibake markers noticeably
          const before = (t.match(/[ÃƒÃ‚Ã¢â‚¬]/g)||[]).length;
          const after = (fixed.match(/[ÃƒÃ‚Ã¢â‚¬]/g)||[]).length;
          if(after < before) t = fixed;
        }catch(e){}
      }

      // 2) Replace Windows-1252 mojibake sequences (fallback)
      t = t
        .replace(/Ã¢â‚¬Â“|Ã¢â‚¬â€œ/g, 'â€“')  // en dash
        .replace(/Ã¢â‚¬Â”|Ã¢â‚¬â€/g, 'â€”')  // em dash
        .replace(/Ã¢â‚¬Â˜/g, 'â€˜')
        .replace(/Ã¢â‚¬Â™|Ã¢â‚¬â„¢/g, 'â€™')
        .replace(/Ã¢â‚¬Âœ|Ã¢â‚¬Å“/g, 'â€œ')
        .replace(/Ã¢â‚¬Â|Ã¢â‚¬ï¿½/g, 'â€')
        .replace(/Ã¢â‚¬Â¢/g, 'â€¢')
        .replace(/Ã¢â‚¬Â¦/g, 'â€¦')
        .replace(/Ã¢â€žÂ¢/g, 'â„¢');

      // 3) Remove common stray chars
      t = t.replace(/\u00C2/g, '');   // 'Ã‚'
      t = t.replace(/\uFFFD/g, '');   // replacement char
      t = t.replace(/\u00A0/g, ' ');  // NBSP -> space

      // Collapse excessive whitespace
      t = t.replace(/[\t\r]+/g, ' ').replace(/\n{3,}/g, '\n\n');

      return t;
    }

    function stripHtmlToText(s){
      if(!s) return '';
      // Remove tags and decode a few common entities
      return String(s)
        .replace(/<style[\s\S]*?<\/style>/gi,' ')
        .replace(/<script[\s\S]*?<\/script>/gi,' ')
        .replace(/<[^>]+>/g,' ')
        .replace(/&nbsp;/gi,' ')
        .replace(/&amp;/gi,'&')
        .replace(/&lt;/gi,'<')
        .replace(/&gt;/gi,'>')
        .replace(/&quot;/gi,'"')
        .replace(/&#39;/gi,"'")
        .replace(/\s+/g,' ')
        .trim();
    }

    function buildSearchText(feature){
      // Build a searchable blob including title, description (HTML stripped), and all property values.
      const p = feature.getProperties ? feature.getProperties() : {};
      const title = getTitle(p);
      const descRaw = getDescription(p);
      const descText = stripHtmlToText(descRaw);
      let others = '';
      for(const [k,v] of Object.entries(p)){
        if(k === 'geometry' || k === 'baseStyle' || k === 'folderPath') continue;
        if(v === null || v === undefined) continue;
        if(typeof v === 'object') continue;
        const s = cleanTextEncoding(String(v));
        if(!s) continue;
        others += ` ${k}:${s}`;
      }
      return (cleanTextEncoding(title) + ' ' + cleanTextEncoding(descText) + ' ' + others).toLowerCase();
    }

    function sanitizeDescriptionHtml(desc){
      desc = cleanTextEncoding(desc);
      if(!desc) return '';
      // DOMPurify is loaded from CDN; if it fails, fall back to escaped text.
      if(typeof DOMPurify !== 'undefined'){
        return DOMPurify.sanitize(desc, {
          USE_PROFILES: { html: true },
          ALLOWED_TAGS: [
            'table','thead','tbody','tr','th','td',
            'b','strong','i','em','u','br','p','div','span',
            'ul','ol','li','a','hr'
          ],
          ALLOWED_ATTR: ['href','title','target','rel','style','class','colspan','rowspan']
        });
      }
      return escapeHtml(desc);
    }

    function fmtLatLon(coord3857){const ll=ol.proj.toLonLat(coord3857); return `${ll[1].toFixed(6)}, ${ll[0].toFixed(6)}`;}
    function showError(msg){const el=document.getElementById('err'); el.textContent=msg; el.style.display='block';}

    // -------- URL state (shareable view + toggles + enabled folders)
    function parseUrlState(){
      const params = new URLSearchParams(window.location.search);
      const z = Number(params.get('z'));
      const lon = Number(params.get('lon'));
      const lat = Number(params.get('lat'));
      const sat = params.get('sat') === '1';
      const cluster = params.get('cluster') !== '0';
      const heat = params.get('heat') === '1';
      const foldersRaw = params.get('folders') || '';
      const folders = foldersRaw ? foldersRaw.split('|').map(decodeURIComponent).filter(Boolean) : null;
      return { z, lon, lat, sat, cluster, heat, folders };
    }

    function saveUrlState(){
      // Update URL only on drag/zoom end (moveend), and only if it changes.
      try{
        if(!map || !map.getView) return;
        const view = map.getView();
        const c = view.getCenter && view.getCenter();
        if(!c) return;

        const center = ol.proj.toLonLat(c);
        const z = view.getZoom ? view.getZoom() : null;

        const params = new URLSearchParams(window.location.search);
        if(Number.isFinite(z)) params.set('z', String(Math.round(z*100)/100));
        params.set('lon', String(Math.round(center[0]*1000000)/1000000));
        params.set('lat', String(Math.round(center[1]*1000000)/1000000));

        params.set('sat', document.getElementById('satToggle')?.checked ? '1' : '0');
        params.set('cluster', document.getElementById('clusterToggle')?.checked ? '1' : '0');
        params.set('heat', document.getElementById('heatToggle')?.checked ? '1' : '0');

        if(typeof folderTotalCounts !== 'undefined' && folderTotalCounts.size && enabledFolders.size === folderTotalCounts.size){
          params.delete('folders');
        } else {
          const list = Array.from(enabledFolders).map(encodeURIComponent).join('|');
          params.set('folders', list);
        }

        const newUrl = window.location.pathname + '?' + params.toString();
        const curUrl = window.location.pathname + window.location.search;
        if(newUrl === curUrl) return;
        history.replaceState(null, '', newUrl);
      }catch(e){
        try{ setDebug('saveUrlState error: ' + (e && e.message ? e.message : String(e))); }catch(_){}
      }
    }


    // -------- Base layers
    const osmLayer=new ol.layer.Tile({source:new ol.source.OSM(), visible:true});
    const esriLayer=new ol.layer.Tile({
      source:new ol.source.XYZ({
        url:'https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}',
        attributions:'Tiles Â© Esri'
      }),
      visible:false
    });

    // -------- Sources
    const pointSource=new ol.source.Vector();
    const otherSource=new ol.source.Vector();
    const clusterSource=new ol.source.Cluster({distance:40, minDistance:12, source: pointSource});

    // We'll use a single style function that can "hide" features by returning null.
    const enabledFolders = new Set(); // folder paths that are ON

    function defaultStyleForFeature(f){
      const t = f.getGeometry()?.getType?.() || '';
      if(t==='Point' || t==='MultiPoint'){
        return new ol.style.Style({
          image:new ol.style.Circle({
            radius:6,
            fill:new ol.style.Fill({color:'rgba(220,0,0,.85)'}),
            stroke:new ol.style.Stroke({color:'white', width:1})
          })
        });
      }
      return new ol.style.Style({
        stroke:new ol.style.Stroke({color:'rgba(0,80,200,.9)', width:2}),
        fill:new ol.style.Fill({color:'rgba(0,80,200,.12)'})
      });
    }

    function visibleStyle(feature, resolution){
      // For cluster wrapper feature
      const clustered = feature.get('features');
      if(Array.isArray(clustered)){
        const size = clustered.length;
        if(size===1){
          return visibleStyle(clustered[0], resolution); // defer to real feature
        }
        // Cluster visible if ANY underlying feature is visible
        const anyVisible = enabledFolders.size === 0 || clustered.some(f => enabledFolders.has(f.get('folderPath') || 'Uncategorised'));
        if(!anyVisible) return null;

        return new ol.style.Style({
          image:new ol.style.Circle({
            radius: Math.min(22, 10 + Math.log(size)*6),
            fill:new ol.style.Fill({color:'rgba(0,0,0,0.55)'}),
            stroke:new ol.style.Stroke({color:'rgba(255,255,255,0.9)', width:2})
          }),
          text:new ol.style.Text({
            text:String(size),
            fill:new ol.style.Fill({color:'white'}),
            font:'bold 12px system-ui,-apple-system,Segoe UI,Roboto,Arial,sans-serif'
          })
        });
      }

      const folder = feature.get('folderPath') || 'Uncategorised';
      if(enabledFolders.size && !enabledFolders.has(folder)) return null;

      // Preserve KML-extracted style if present
      const base = feature.get('baseStyle') || (feature.getStyle && feature.getStyle());
      if (typeof base === 'function') return base(feature, resolution);
      return base || defaultStyleForFeature(feature);
    }

    const otherLayer = new ol.layer.Vector({ source: otherSource, style: visibleStyle });
    const clusteredPointLayer = new ol.layer.Vector({ source: clusterSource, visible:true, style: visibleStyle });
    const plainPointLayer = new ol.layer.Vector({ source: pointSource, visible:false, style: visibleStyle });

    // Heatmap layer (points only). Uses pointSource (non-clustered).
    const heatmapLayer = new ol.layer.Heatmap({
      source: pointSource,
      visible: false,
      blur: 18,
      radius: 10,
      weight: function(feature){
        const w = Number(feature.get('weight'));
        return Number.isFinite(w) ? w : 1;
      }
    });

    

    // Go-to coordinate marker (used by coordinate search)
    const gotoMarkerSource = new ol.source.Vector();
    const gotoMarkerLayer = new ol.layer.Vector({
      source: gotoMarkerSource,
      style: new ol.style.Style({
        image: new ol.style.Circle({
          radius: 8,
          fill: new ol.style.Fill({ color: 'rgba(0,0,0,0.75)' }),
          stroke: new ol.style.Stroke({ color: '#fff', width: 2 })
        })
      })
    });

// -------- Map
    const map=new ol.Map({
      target:'map',
      layers:[osmLayer, esriLayer, otherLayer, gotoMarkerLayer, heatmapLayer, clusteredPointLayer, plainPointLayer],
      view:new ol.View({center: ol.proj.fromLonLat([53,32]), zoom:5})
    });

    // Apply URL state (if present)
    const urlState = parseUrlState();
    if(Number.isFinite(urlState.lon) && Number.isFinite(urlState.lat)){
      map.getView().setCenter(ol.proj.fromLonLat([urlState.lon, urlState.lat]));
    }
    if(Number.isFinite(urlState.z)){
      map.getView().setZoom(urlState.z);
    }


    function fitToAll(){
      const exts=[];
      if(pointSource.getFeatures().length) exts.push(pointSource.getExtent());
      if(otherSource.getFeatures().length) exts.push(otherSource.getExtent());
      if(!exts.length) return;
      let extent=exts[0].slice();
      for(let i=1;i<exts.length;i++) ol.extent.extend(extent, exts[i]);
      map.getView().fit(extent, {padding:[40,40,40,40], maxZoom:14});
    }

    // -------- Read folder structure from KML XML
    // This reads <Folder><name>â€¦</name> nesting and assigns each <Placemark> a folder "path" like "Parent / Child".
    // Matching placemarks to OpenLayers features:
    // - If Placemark has an "id" attribute and OL feature has an id, we match by id.
    // - Otherwise we fall back to document order (works for most KML exports, but not guaranteed).
    function readPlacemarkFolderMeta(kmlText){
      const parser = new DOMParser();
      const xml = parser.parseFromString(kmlText, 'application/xml');

      // Detect parse errors
      const perr = xml.getElementsByTagName('parsererror');
      if(perr && perr.length) throw new Error('KML XML parse error.');

      const metaById = new Map();
      const metaInOrder = [];

      function elText(el, tag){
        const n = el.getElementsByTagName(tag)[0];
        return n ? (n.textContent || '').trim() : '';
      }

      function walk(node, path){
        // Only consider element nodes
        for(const child of node.children){
          const local = child.localName;

          if(local === 'Folder'){
            const fname = elText(child, 'name') || 'Folder';
            walk(child, path.concat([fname]));
          } else if(local === 'Placemark'){
            const pname = elText(child, 'name') || '';
            const pid = child.getAttribute('id') || '';
            const folderPath = path.length ? path.join(' / ') : 'Uncategorised';
            const m = { id: pid, name: pname, folderPath };

            if(pid) metaById.set(pid, m);
            metaInOrder.push(m);
          } else {
            // Recurse into Document or other containers
            walk(child, path);
          }
        }
      }

      // Start at Document if present
      const docs = xml.getElementsByTagNameNS('*','Document');
      if(docs && docs.length){
        walk(docs[0], []);
      } else {
        walk(xml.documentElement, []);
      }
      return { metaById, metaInOrder };
    }

    
    async function fetchTextWithTimeout(url, ms=20000){
      const controller = new AbortController();
      const t = setTimeout(()=>controller.abort(), ms);
      try{
        const res = await fetch(url, { cache: 'no-store', signal: controller.signal });
        const ct = res.headers.get('content-type') || '';
        // Use arrayBuffer+TextDecoder for encoding control
        const buf = await res.arrayBuffer();
        let text = new TextDecoder('utf-8', { fatal: false }).decode(buf);
        const encMatch = text.match(/<\?xml[^>]*encoding=["']([^"']+)["']/i);
        if(encMatch && encMatch[1]){
          try{ text = new TextDecoder(encMatch[1].toLowerCase(), { fatal: false }).decode(buf); }catch(e){}
        }
        return { ok: res.ok, status: res.status, statusText: res.statusText, ct, text, url };
      } finally {
        clearTimeout(t);
      }
    }

// -------- Load KML and build features + folders UI
    const KML_URL = new URL('Iran_new.kml', window.location.href).toString();
    const KML_FALLBACKS = [
      KML_URL,
      'https://raw.githubusercontent.com/AuroraIntel99/Iran-kml-map/main/Iran_new.kml',
      'https://raw.githubusercontent.com/AuroraIntel99/Iran-kml-map/refs/heads/main/Iran_new.kml'
    ];

    (async ()=>{
      try{
        const res = await fetch(KML_URL, {cache:'no-store'});
        if(!res.ok) throw new Error(`HTTP ${res.status} ${res.statusText} fetching ${KML_URL}`);
        const buf = await res.arrayBuffer();

        // Decode with best-effort encoding detection.
        // 1) Try UTF-8 first (most KML).
        let text = new TextDecoder('utf-8', { fatal: false }).decode(buf);

        // 2) If XML declares an encoding, try that.
        const encMatch = text.match(/<\?xml[^>]*encoding=["']([^"']+)["']/i);
        if(encMatch && encMatch[1]){
          const enc = encMatch[1].toLowerCase();
          try { text = new TextDecoder(enc, { fatal: false }).decode(buf); } catch(e){}
        }

        // 3) If we see classic mojibake markers, try Windows-1252 as a fallback.
        if(/[\u00C2\u00C3]/.test(text) && /Ã‚|Ãƒ/.test(text)){
          try { text = new TextDecoder('windows-1252', { fatal: false }).decode(buf); } catch(e){}
        }

        if(text.startsWith('version https://git-lfs.github.com/spec/v1')){
          throw new Error('Your KML is being served as a Git LFS pointer, not real XML. Remove Git LFS for .kml and commit the actual file.');
        }

        const { metaById, metaInOrder } = readPlacemarkFolderMeta(text);

        const kmlFormat = new ol.format.KML({extractStyles:true});
        const features = kmlFormat.readFeatures(text, { featureProjection: map.getView().getProjection() });

        if(!features.length) throw new Error('KML loaded, but 0 features were parsed.');

        setDebug(`Fetched ${text.length} chars from ${KML_URL} â€¢ Parsed ${features.length} feature(s)`);

        // Assign folderPath + preserve base style
        // Try match by id if possible
        let matchedById = 0;
        for(const f of features){
          // Preserve the extracted style (if any) because we use a style function now
          if(f.getStyle && f.getStyle()){
            f.set('baseStyle', f.getStyle());
            f.setStyle(null); // allow layer style function to drive rendering
          }

          const fid = (typeof f.getId === 'function') ? f.getId() : null;
          if(fid && metaById.has(String(fid))){
            const m = metaById.get(String(fid));
            f.set('folderPath', m.folderPath);
            matchedById++;
          }
        }

        // Fallback: assign by document order for any still missing
        if(matchedById === 0){
          // Assign in order (best-effort)
          for(let i=0;i<features.length;i++){
            const f = features[i];
            if(f.get('folderPath')) continue;
            const m = metaInOrder[i];
            f.set('folderPath', (m && m.folderPath) ? m.folderPath : 'Uncategorised');
          }
        } else {
          // Fill any leftover without matches
          for(const f of features){
            if(!f.get('folderPath')) f.set('folderPath', 'Uncategorised');
          }
        }

        // Precompute searchable text for fast filtering
        for(const f of features){
          try{ f.set('_searchText', buildSearchText(f)); }catch(e){}
        }

        // Populate sources
        for(const f of features){
          const g=f.getGeometry(); if(!g) continue;
          const t=g.getType();
          if(t==='Point' || t==='MultiPoint') pointSource.addFeature(f);
          else otherSource.addFeature(f);
        }

        // Build folder set (default ON)
        const all = [...pointSource.getFeatures(), ...otherSource.getFeatures()];
        const folderCounts = new Map();
        for(const f of all){
          const p = f.get('folderPath') || 'Uncategorised';
          folderCounts.set(p, (folderCounts.get(p) || 0) + 1);
        }
        for(const k of folderCounts.keys()) enabledFolders.add(k);

        if(urlState && Array.isArray(urlState.folders)){
          enabledFolders.clear();
          for(const f of urlState.folders){ enabledFolders.add(f); }
        }

        computeFolderExtents();
        buildFolderTreeUI(folderCounts);
        buildSidebar(); // uses enabledFolders to filter list
        fitToAll();
        requestAnimationFrame(()=>updateFoldersInView());

        const pe = pointSource.getExtent();
        const oe = otherSource.getExtent();
        const sample = features[0];
        const sc = sample?.getGeometry?.() ? ol.extent.getCenter(sample.getGeometry().getExtent()) : null;
        setDebug(`Fetched ${text.length} chars from ${KML_URL} â€¢ Parsed ${features.length} feature(s) â€¢ Points: ${pointSource.getFeatures().length} â€¢ Other: ${otherSource.getFeatures().length}\nPoint extent: ${extentToStr(pe)}\nOther extent: ${extentToStr(oe)}\nSample center (3857): ${sc ? sc.map(v=>v.toFixed(2)).join(', ') : '(none)'}`);

        document.getElementById('count').textContent =
          `${pointSource.getFeatures().length} point(s), ${otherSource.getFeatures().length} other feature(s)`;

        // Ensure initial render with enabled folders
        otherLayer.changed(); clusteredPointLayer.changed(); plainPointLayer.changed(); heatmapLayer.changed();

      }catch(err){
        document.getElementById('count').textContent = 'Load error';
        showError(String(err));
        console.error(err);
      }
    })();

    // -------- Folder UI (tree + zoom-to-folder) + in-view counts
    const foldersEl = document.getElementById('folders');

    // Build a tree from leaf folder paths like "A / B / C"
    function makeTree(pathsWithCounts){
      const root = { name: 'root', path: '', children: new Map(), leafPaths: [] };

      for(const [path, totalCount] of pathsWithCounts.entries()){
        const parts = path.split(' / ');
        let node = root;
        let curPath = '';
        for(const part of parts){
          curPath = curPath ? (curPath + ' / ' + part) : part;
          if(!node.children.has(part)){
            node.children.set(part, { name: part, path: curPath, children: new Map(), leafPaths: [] });
          }
          node = node.children.get(part);
        }
        node.leafPaths.push(path); // leaf is the full path itself
      }
      return root;
    }

    // Map: folderPath -> extent (for zoom). We'll also aggregate for parent nodes.
    const folderExtent = new Map(); // path -> extent in map projection
    function extendExtent(a, b){
      if(!b) return a;
      if(!a) return b.slice();
      const out = a.slice();
      if(b[0] < out[0]) out[0] = b[0];
      if(b[1] < out[1]) out[1] = b[1];
      if(b[2] > out[2]) out[2] = b[2];
      if(b[3] > out[3]) out[3] = b[3];
      return out;
    }

    function computeFolderExtents(){
      folderExtent.clear();
      const all = [...pointSource.getFeatures(), ...otherSource.getFeatures()];
      for(const f of all){
        const folder = f.get('folderPath') || 'Uncategorised';
        const g = f.getGeometry();
        if(!g) continue;
        const ext = g.getExtent();
        folderExtent.set(folder, extendExtent(folderExtent.get(folder), ext));
      }
      // Aggregate to parents
      for(const key of Array.from(folderExtent.keys())){
        const parts = key.split(' / ');
        for(let i=1;i<parts.length;i++){
          const parent = parts.slice(0,i).join(' / ');
          folderExtent.set(parent, extendExtent(folderExtent.get(parent), folderExtent.get(key)));
        }
      }
    }

    // Utilities for enabled state across a tree
    function getDescendantLeafPaths(node){
      let leaves = [];
      if(node.leafPaths?.length) leaves = leaves.concat(node.leafPaths);
      for(const child of node.children.values()){
        leaves = leaves.concat(getDescendantLeafPaths(child));
      }
      return leaves;
    }

    function setEnabledForLeaves(leaves, enabled){
      if(enabled){
        for(const p of leaves) enabledFolders.add(p);
      } else {
        for(const p of leaves) enabledFolders.delete(p);
      }
    }

    function computeNodeCheckState(leaves){
      let on = 0;
      for(const p of leaves){
        if(enabledFolders.has(p)) on++;
      }
      if(on === 0) return 'off';
      if(on === leaves.length) return 'on';
      return 'partial';
    }

    function zoomToPath(path){
      const ext = folderExtent.get(path);
      if(!ext) return;
      map.getView().fit(ext, { padding:[60,60,60,60], maxZoom: 15, duration: 350 });
    }

    // Render tree using <details> for collapsible folders
    function renderNode(node, inViewCounts){
      const leaves = getDescendantLeafPaths(node);
      const state = computeNodeCheckState(leaves);

      // in-view aggregation
      let inView = 0;
      for(const p of leaves) inView += (inViewCounts.get(p) || 0);

      const total = leaves.reduce((acc, p) => acc + (folderTotalCounts.get(p) || 0), 0);

      const wrapper = document.createElement('details');
      wrapper.dataset.path = node.path;
      wrapper.open = true;

      const summary = document.createElement('summary');

      const row = document.createElement('div');
      row.className = 'node';
      row.dataset.path = node.path;
      row.style.opacity = inView ? '1' : '0.35';

      const cb = document.createElement('input');
      cb.type = 'checkbox';
      cb.checked = (state === 'on');
      cb.indeterminate = (state === 'partial');
      cb.addEventListener('click', (e)=> e.stopPropagation());
      cb.addEventListener('change', (e)=>{
        e.stopPropagation();
        setEnabledForLeaves(leaves, cb.checked);
        otherLayer.changed(); clusteredPointLayer.changed(); plainPointLayer.changed(); heatmapLayer.changed(); heatmapLayer.changed();
        renderList(document.getElementById('search').value);
        overlay.setPosition(undefined); container.style.display='none';
        
        updateFoldersInView();
      });

      const label = document.createElement('div');
      label.className = 'label';
      // Folder icons: twisty + closed/open folder
      const twisty = document.createElement('span');
      twisty.className = 'twisty';
      const ficon = document.createElement('span');
      ficon.className = 'folderIcon';
      const nameSpan = document.createElement('span');
      nameSpan.textContent = node.name;
      label.appendChild(twisty);
      label.appendChild(ficon);
      label.appendChild(nameSpan);

      const meta = document.createElement('div');
      meta.className = 'meta';

      const counts = document.createElement('div');
      counts.className = 'counts';
      counts.innerHTML = `<span class="total">${total}</span> total â€¢ <span class="inView">${inView}</span> in view`;

      const zoomBtn = document.createElement('button');
      zoomBtn.className = 'zoomBtn';
      zoomBtn.type = 'button';
      zoomBtn.textContent = 'Fit';
      zoomBtn.title = 'Zoom to this folder';
      zoomBtn.addEventListener('click', (e)=>{
        e.preventDefault();
        e.stopPropagation();
        zoomToPath(node.path);
      });

      meta.appendChild(counts);
      meta.appendChild(zoomBtn);

      row.appendChild(cb);
      row.appendChild(label);
      row.appendChild(meta);

      summary.appendChild(row);
      wrapper.appendChild(summary);

      // Children
      const kids = document.createElement('div');
      for(const child of Array.from(node.children.values()).sort((a,b)=>a.name.localeCompare(b.name))){
        kids.appendChild(renderNode(child, inViewCounts));
      }
      wrapper.appendChild(kids);
      return wrapper;
    }

    // Store totals (leaf path -> count)
    const folderTotalCounts = new Map();

    function buildFolderTreeUI(folderCounts){
      // Clear cached descendant leaf sets (DOM will be rebuilt)
      if(window.nodeLeavesCache) window.nodeLeavesCache = undefined;
      foldersEl.innerHTML = '';
      folderTotalCounts.clear();
      for(const [k,v] of folderCounts.entries()) folderTotalCounts.set(k,v);

      const root = makeTree(folderCounts);
      const inViewCounts = computeInViewCounts();

      // Render top-level nodes
      for(const child of Array.from(root.children.values()).sort((a,b)=>a.name.localeCompare(b.name))){
        foldersEl.appendChild(renderNode(child, inViewCounts));
      }
    }

    function computeInViewCounts(){
      // Hybrid extent calc: prefer view.calculateExtent(size) (matches OL internals),
      // with robust size detection + pixel->coord fallback for iOS edge cases.
      try{ map.updateSize(); }catch(e){}

      let size = map.getSize();
      if(!size || !size[0] || !size[1]){
        const vp = map.getViewport?.();
        const r = vp && vp.getBoundingClientRect ? vp.getBoundingClientRect() : null;
        if(r && r.width && r.height) size = [Math.round(r.width), Math.round(r.height)];
      }
      if(!size || !size[0] || !size[1]) size = [800, 600];

      let extent = map.getView().calculateExtent(size);

      // Fallback if extent looks invalid
      if(!extent || extent.length !== 4 || extent.some(v => !Number.isFinite(v))){
        const w = Math.max(1, (size[0]||800) - 1);
        const h = Math.max(1, (size[1]||600) - 1);
        const c1 = map.getCoordinateFromPixel([0, 0]);
        const c2 = map.getCoordinateFromPixel([w, h]);
        const minX = Math.min(c1[0], c2[0]);
        const minY = Math.min(c1[1], c2[1]);
        const maxX = Math.max(c1[0], c2[0]);
        const maxY = Math.max(c1[1], c2[1]);
        extent = [minX, minY, maxX, maxY];
      }

      const inViewCounts = new Map();
      pointSource.forEachFeatureIntersectingExtent(extent, f => {
        const folder = f.get('folderPath') || 'Uncategorised';
        inViewCounts.set(folder, (inViewCounts.get(folder) || 0) + 1);
      });
      otherSource.forEachFeatureIntersectingExtent(extent, f => {
        const folder = f.get('folderPath') || 'Uncategorised';
        inViewCounts.set(folder, (inViewCounts.get(folder) || 0) + 1);
      });
      return inViewCounts;
    }


    function updateFoldersInView(){
      const inViewCounts = computeInViewCounts();

      // Update counts + opacity for each rendered node using its data-path
      document.querySelectorAll('#folders .node').forEach(row => {
        const path = row.dataset.path || '';
        if(!path) return;

        // For this node, "in view" should include all descendant leaf paths.
        // We precompute descendant leaf sets per node for performance by caching in a Map.
      });

      // Cache descendant leaf paths per node path (computed once per load)
      if(typeof nodeLeavesCache === 'undefined'){
        window.nodeLeavesCache = new Map();
        // Build cache by walking the DOM tree: each <details> corresponds to a node.
        document.querySelectorAll('#folders details').forEach(d => {
          const p = d.dataset.path || '';
          if(!p) return;
          // Descendant leaf paths are the enabledFolders universe in folderTotalCounts that start with this path.
          const leaves = [];
          for(const leaf of folderTotalCounts.keys()){
            if(leaf === p || leaf.startsWith(p + ' / ')) leaves.push(leaf);
          }
          window.nodeLeavesCache.set(p, leaves);
        });
      }

      document.querySelectorAll('#folders .node').forEach(row => {
        const path = row.dataset.path || '';
        if(!path) return;

        const leaves = window.nodeLeavesCache.get(path) || [];
        let inView = 0;
        let total = 0;
        for(const leaf of leaves){
          inView += (inViewCounts.get(leaf) || 0);
          total += (folderTotalCounts.get(leaf) || 0);
        }

        const inViewEl = row.querySelector('.inView');
        const totalEl = row.querySelector('.total');
        if(inViewEl) inViewEl.textContent = String(inView);
        if(totalEl) totalEl.textContent = String(total);

        row.style.opacity = inView ? '1' : '0.35';
      });

      
    }

    document.getElementById('allOn').onclick = ()=>{
      for(const k of folderTotalCounts.keys()) enabledFolders.add(k);
      otherLayer.changed(); clusteredPointLayer.changed(); plainPointLayer.changed(); heatmapLayer.changed(); heatmapLayer.changed();
      renderList(document.getElementById('search').value);
      
      updateFoldersInView();
    };
    document.getElementById('allOff').onclick = ()=>{
      enabledFolders.clear();
      otherLayer.changed(); clusteredPointLayer.changed(); plainPointLayer.changed(); heatmapLayer.changed(); heatmapLayer.changed();
      renderList(document.getElementById('search').value);
      overlay.setPosition(undefined); container.style.display='none';
      
      updateFoldersInView();
    };

    // Expand/collapse all folder nodes
    document.getElementById('expandAll').onclick = ()=>{
      document.querySelectorAll('#folders details').forEach(d => d.open = true);
    };
    document.getElementById('collapseAll').onclick = ()=>{
      document.querySelectorAll('#folders details').forEach(d => d.open = false);
      // Keep the user from "losing" the list entirely: ensure top-level nodes remain visible in collapsed state
    };


    map.on('moveend', ()=>{ setTimeout(()=>{ updateFoldersInView(); saveUrlState(); }, 0); });
    
    // Extra robustness: also update on view changes (covers some mobile edge cases)
    const view = map.getView();
    view.on('change:center', ()=>updateFoldersInView());
    view.on('change:resolution', ()=>updateFoldersInView());map.on('moveend', ()=>{ setTimeout(()=>updateFoldersInView(), 0); });
    

    // -------- Sidebar list + search (respects folder toggles)
    const listEl=document.getElementById('featureList');
    const searchEl=document.getElementById('search');
    let allFeatures=[];

    function buildSidebar(){
      // Ensure search text exists
      for(const feat of [...pointSource.getFeatures(), ...otherSource.getFeatures()]){
        if(!feat.get('_searchText')){ try{ feat.set('_searchText', buildSearchText(feat)); }catch(e){} }
      }

      allFeatures=[...pointSource.getFeatures(), ...otherSource.getFeatures()];
      allFeatures.sort((a,b)=> getTitle(a.getProperties()).localeCompare(getTitle(b.getProperties())));
      renderList('');
    }

    
    function parseSearchPhrase(raw){
      const q = (raw || '').trim();
      if(!q) return { phrase: '', mode: 'empty' };
      // If wrapped in quotes, treat as exact phrase (quotes removed)
      const m = q.match(/^["â€œâ€](.*)["â€œâ€]$/);
      if(m) return { phrase: m[1].trim().toLowerCase(), mode: 'phrase' };
      return { phrase: q.toLowerCase(), mode: 'contains' };
    }

    function getMatchingFeatures(rawFilter){
      const { phrase, mode } = parseSearchPhrase(rawFilter);
      if(mode === 'empty') return [];
      const enabledOk = (feat) => {
        const folder = feat.get('folderPath') || 'Uncategorised';
        return (!enabledFolders.size) || enabledFolders.has(folder);
      };
      const all = [...pointSource.getFeatures(), ...otherSource.getFeatures()];
      return all.filter(feat => {
        if(!enabledOk(feat)) return false;
        const st = (feat.get('_searchText') || '').toString();
        return st.includes(phrase);
      });
    }

    function fitToFeatureSet(features){
      if(!features || !features.length) return;
      let ext = null;
      for(const f of features){
        const g = f.getGeometry && f.getGeometry();
        if(!g) continue;
        const e = g.getExtent();
        if(!ext) ext = e.slice();
        else{
          if(e[0] < ext[0]) ext[0] = e[0];
          if(e[1] < ext[1]) ext[1] = e[1];
          if(e[2] > ext[2]) ext[2] = e[2];
          if(e[3] > ext[3]) ext[3] = e[3];
        }
      }
      if(!ext) return;
      // Avoid over-zooming on a single point
      map.getView().fit(ext, { padding:[70,70,70,70], maxZoom: 14, duration: 350 });
    }

function renderList(filter){
      const f=filter.trim().toLowerCase();
      listEl.innerHTML='';

      const visible = allFeatures.filter(feat => enabledFolders.has(feat.get('folderPath') || 'Uncategorised'));

      const filtered = f ? visible.filter(feat=>{
        const p=feat.getProperties();
        const st = (feat.get('_searchText') || '').toString();
        return st.includes(f);
      }) : visible;

      for(const feat of filtered){
        const p=feat.getProperties();
        const name=getTitle(p);
        const desc=getDescription(p);
        const folder = feat.get('folderPath') || 'Uncategorised';

        const li=document.createElement('li');
        li.className='item';
        li.innerHTML = `<div class="name">${escapeHtml(name)}</div>
          <div class="meta">${escapeHtml(folder)} â€¢ ${escapeHtml(desc ? desc.slice(0,90) : 'No description')}${desc && desc.length>90 ? ' â€¦' : ''}</div>`;
        li.addEventListener('click', ()=>{
          const g=feat.getGeometry(); if(!g) return;
          const extent=g.getExtent();
          map.getView().fit(extent, {padding:[60,60,60,60], maxZoom:15, duration:300});
          const center=ol.extent.getCenter(extent);
          openPopupForFeatures([feat], center, 0);
          closePanelOnMobile();
        });
        listEl.appendChild(li);
      }

      document.getElementById('count').textContent =
        `${filtered.length} shown / ${visible.length} visible / ${allFeatures.length} total`;
    }

    searchEl.addEventListener('input', (e)=> renderList(e.target.value));

    // Press Enter in the search box to auto-zoom to matching results
    searchEl.addEventListener('keydown', (e)=>{
      if(e.key !== 'Enter') return;
      const q = searchEl.value || '';
      const matches = getMatchingFeatures(q);
      if(matches.length){
        fitToFeatureSet(matches);
      }
    });

    // Optional: auto-zoom after you stop typing (gentle debounce). Toggle via AUTO_FIT_ON_TYPE.
    const AUTO_FIT_ON_TYPE = false;
    let fitTimer = null;
    searchEl.addEventListener('input', ()=>{
      if(!AUTO_FIT_ON_TYPE) return;
      clearTimeout(fitTimer);
      fitTimer = setTimeout(()=>{
        const q = searchEl.value || '';
        const matches = getMatchingFeatures(q);
        if(matches.length) fitToFeatureSet(matches);
      }, 450);
    });


    // -------- Coordinate search (supports decimal, DMS, Plus Codes) with optional zoom
    const coordInput = document.getElementById('coordSearch');
    const coordGoBtn = document.getElementById('coordGo');

    function parseZoomToken(t){
      let zoom = null;
      const zMatch = t.match(/(?:\bz\s*=\s*|\bzoom\s+|@)(\d+(?:\.\d+)?)/i);
      if(zMatch){
        zoom = Number(zMatch[1]);
        t = t.replace(zMatch[0], '').trim();
      }
      return { t, zoom };
    }

    function parseDecimalCoords(t){
      t = t.replace(/[()]/g, '').trim();
      const parts = t.split(/\s*,\s*|\s+/).filter(Boolean);
      if(parts.length < 2) return null;

      const a = Number(parts[0]);
      const b = Number(parts[1]);
      if(!Number.isFinite(a) || !Number.isFinite(b)) return null;

      // Heuristic: latitude is within [-90,90]. If only one fits, choose that.
      let lat, lon;
      const aIsLat = Math.abs(a) <= 90;
      const bIsLat = Math.abs(b) <= 90;

      if(aIsLat && !bIsLat){ lat = a; lon = b; }
      else if(!aIsLat && bIsLat){ lon = a; lat = b; }
      else { lat = a; lon = b; } // ambiguous -> assume lat,lon

      if(Math.abs(lat) > 90 || Math.abs(lon) > 180) return null;
      return { lat, lon };
    }

    // DMS helpers
    function dmsPartToDecimal(deg, min, sec, hemi){
      let v = Math.abs(Number(deg)) + (Number(min)||0)/60 + (Number(sec)||0)/3600;
      if(!Number.isFinite(v)) return null;
      hemi = (hemi||'').toUpperCase();
      if(hemi === 'S' || hemi === 'W') v = -v;
      return v;
    }

    function parseDMS(t){
      // Accept examples:
      // 35Â°41'21"N 51Â°23'20"E
      // 35 41 21 N, 51 23 20 E
      // 35Â°41.35'N 51Â°23.33'E
      const cleaned = t.replace(/,/g,' ').replace(/\s+/g,' ').trim();

      // Try a robust regex for two DMS groups with hemisphere letters
      const re1 = /(-?\d+(?:\.\d+)?)\s*(?:Â°|d)?\s*(\d+(?:\.\d+)?)?\s*(?:'|m)?\s*(\d+(?:\.\d+)?)?\s*(?:"|s)?\s*([NSEW])\s+(-?\d+(?:\.\d+)?)\s*(?:Â°|d)?\s*(\d+(?:\.\d+)?)?\s*(?:'|m)?\s*(\d+(?:\.\d+)?)?\s*(?:"|s)?\s*([NSEW])/i;
      const m = cleaned.match(re1);
      if(!m) return null;

      const lat1 = dmsPartToDecimal(m[1], m[2], m[3], m[4]);
      const lon1 = dmsPartToDecimal(m[5], m[6], m[7], m[8]);
      if(lat1 === null || lon1 === null) return null;

      // Determine which is lat/lon based on hemisphere letters
      const hemiA = m[4].toUpperCase();
      const hemiB = m[8].toUpperCase();
      let lat, lon;
      if((hemiA === 'N' || hemiA === 'S') && (hemiB === 'E' || hemiB === 'W')){
        lat = lat1; lon = lon1;
      } else if((hemiA === 'E' || hemiA === 'W') && (hemiB === 'N' || hemiB === 'S')){
        lon = lat1; lat = lon1;
      } else {
        lat = lat1; lon = lon1;
      }

      if(Math.abs(lat) > 90 || Math.abs(lon) > 180) return null;
      return { lat, lon };
    }

    function parsePlusCode(t){
      // Full Plus Codes contain a '+' and at least 8 characters before it (e.g., 8FVC9G8F+5V)
      const raw = t.trim().toUpperCase().replace(/\s/g,'');
      if(!raw.includes('+')) return null;
      // Basic validation
      if(!/^[23456789CFGHJMPQRVWX\+]+$/.test(raw)) return null;
      if(typeof OpenLocationCode === 'undefined') return null;

      try{
        if(!OpenLocationCode.isFull(raw)) return null; // short codes need locality; we don't support that offline
        const area = OpenLocationCode.decode(raw);
        const lat = (area.latitudeLo + area.latitudeHi) / 2;
        const lon = (area.longitudeLo + area.longitudeHi) / 2;
        if(Math.abs(lat) > 90 || Math.abs(lon) > 180) return null;
        return { lat, lon, label: raw };
      }catch(e){
        return null;
      }
    }

    async function parseLocation(text){
      if(!text) return null;
      let t = text.trim();

      // Optional zoom token
      const z = parseZoomToken(t);
      t = z.t;
      const zoom = z.zoom;
      // 1) Plus Code (offline, full codes only)
      const pc = parsePlusCode(t);
      if(pc) return { ...pc, zoom: zoom ?? 14 };

      // 2) DMS
      const dms = parseDMS(t);
      if(dms) return { ...dms, zoom: zoom ?? 12 };

      // 3) Decimal coords
      const dec = parseDecimalCoords(t);
      if(dec) return { ...dec, zoom: zoom ?? 10 };

      return null;
    }

    function gotoLocation(loc){
      const { lat, lon, zoom, label } = loc;
      const coord3857 = ol.proj.fromLonLat([lon, lat]);

      gotoMarkerSource.clear();
      gotoMarkerSource.addFeature(new ol.Feature(new ol.geom.Point(coord3857)));

      const view = map.getView();
      const targetZoom = Number.isFinite(zoom) ? zoom : Math.max(view.getZoom(), 10);
      view.animate({ center: coord3857, duration: 450 }, { zoom: targetZoom, duration: 450 });

      content.innerHTML = `
        <div class="popup-title">Location</div>
        ${label ? `<div style="margin:0 0 6px;opacity:.85;"><b>${escapeHtml(label)}</b></div>` : ''}
        <div style="margin:6px 0 10px;opacity:.75;">Lat: ${lat.toFixed(6)}<br/>Lon: ${lon.toFixed(6)}</div>
        <div style="opacity:.75;">Formats: decimal, DMS, Plus Code</div>
      `;
      overlay.setPosition(coord3857);
      container.style.display='block';

      
    }

    async function doLocationSearch(){
      try{
        const loc = await parseLocation(coordInput.value);
        if(!loc){
          showError('Could not parse location. Try: "35.6892, 51.3890 @12", DMS like "35Â°41\'21\"N 51Â°23\'20\"E", a full Plus Code like "8FVC9G8F+5V", ');
          setTimeout(()=>{ const el=document.getElementById('err'); if(el) el.style.display='none'; }, 4200);
          return;
        }
        gotoLocation(loc);
        closePanelOnMobile();
      }catch(err){
        showError(String(err));
        setTimeout(()=>{ const el=document.getElementById('err'); if(el) el.style.display='none'; }, 5200);
      }
    }

    coordGoBtn.addEventListener('click', doLocationSearch);
    coordInput.addEventListener('keydown', (e)=>{ if(e.key === 'Enter') doLocationSearch(); });



    // -------- Popup + overlap nav (only for visible features)
    const container=document.getElementById('popup');
    const content=document.getElementById('popup-content');
    const closer=document.getElementById('popup-closer');
    const overlay=new ol.Overlay({element:container, autoPan:{animation:{duration:250}}});
    map.addOverlay(overlay);
    closer.onclick=(evt)=>{evt.preventDefault(); overlay.setPosition(undefined); container.style.display='none'; closer.blur(); return false;};

    function buildPropsTable(props){
      const ignored=new Set(['geometry','styleUrl','style','name','Name','NAME','description','Description','folderPath','baseStyle']);
      let rows='';
      for(const [k,v] of Object.entries(props)){
        if(ignored.has(k)) continue;
        if(v===null||v===undefined) continue;
        const vs=String(v).trim(); if(!vs) continue;
        rows += `<tr><td style="padding:4px 10px 4px 0;vertical-align:top;opacity:.75;">${escapeHtml(k)}</td>
                 <td style="padding:4px 0;vertical-align:top;">${escapeHtml(vs)}</td></tr>`;
      }
      return rows ? `<table style="border-collapse:collapse;width:100%;">${rows}</table>` : '';
    }

    function openPopupForFeatures(featureList, coordinate, idx){
      const i=Math.max(0, Math.min(idx, featureList.length-1));
      const feat=featureList[i];
      const props=feat.getProperties();
      const title=getTitle(props);
      const desc=getDescription(props);
      const descHtml = sanitizeDescriptionHtml(desc);
      const folder = feat.get('folderPath') || 'Uncategorised';
      const table=buildPropsTable(props);

      const coordLine=`<div style="margin:6px 0 10px;opacity:.75;">Folder: ${escapeHtml(folder)}<br/>Location: ${escapeHtml(fmtLatLon(coordinate))}</div>`;
      const nav = featureList.length>1 ? `
        <div class="popup-nav">
          <button class="btn" id="prevBtn" ${i===0?'disabled':''}>â† Prev</button>
          <span>${i+1} / ${featureList.length}</span>
          <button class="btn" id="nextBtn" ${i===featureList.length-1?'disabled':''}>Next â†’</button>
        </div>` : '';

      content.innerHTML = `
        <div class="popup-title">${escapeHtml(title)}</div>
        ${descHtml ? `<div class="descHtml">${descHtml}</div>` : ''}
        ${coordLine}
        ${table || `<div style="opacity:.75;">No attributes found</div>`}
        ${nav}
      `;

      overlay.setPosition(coordinate);
      container.style.display='block';

      if(featureList.length>1){
        const prevBtn=document.getElementById('prevBtn');
        const nextBtn=document.getElementById('nextBtn');
        if(prevBtn) prevBtn.onclick=()=> openPopupForFeatures(featureList, coordinate, i-1);
        if(nextBtn) nextBtn.onclick=()=> openPopupForFeatures(featureList, coordinate, i+1);
      }
    }

    map.on('singleclick', (evt)=>{
      const hit=[];
      map.forEachFeatureAtPixel(evt.pixel, (feat)=>{
        const clustered=feat.get('features');
        if(Array.isArray(clustered)) clustered.forEach(f=> hit.push(f));
        else hit.push(feat);
      }, {hitTolerance: 12});

      // Filter to visible features only
      const visibleHit = hit.filter(f => enabledFolders.has(f.get('folderPath') || 'Uncategorised'));

      if(!visibleHit.length){overlay.setPosition(undefined); container.style.display='none'; return;}

      const uniq=[]; const seen=new Set();
      for(const f of visibleHit){const id=f.ol_uid; if(seen.has(id)) continue; seen.add(id); uniq.push(f);}
      openPopupForFeatures(uniq, evt.coordinate, 0);
    });

    // -------- Toggles
    document.getElementById('satToggle').addEventListener('change', (e)=>{
      const on=e.target.checked; esriLayer.setVisible(on); osmLayer.setVisible(!on);
      
    });
    document.getElementById('clusterToggle').addEventListener('change', (e)=>{
      const on=e.target.checked; clusteredPointLayer.setVisible(on); plainPointLayer.setVisible(!on);
    });
    document.getElementById('heatToggle').addEventListener('change', (e)=>{
      const on = e.target.checked;
      heatmapLayer.setVisible(on);
      if(on){
        document.getElementById('clusterToggle').checked = false;
        clusteredPointLayer.setVisible(false);
        plainPointLayer.setVisible(true);
      } else {
        const cOn = document.getElementById('clusterToggle').checked;
        clusteredPointLayer.setVisible(cOn);
        plainPointLayer.setVisible(!cOn);
      }
      
    });


    

    // Initialise toggle states from URL (after listeners are bound)
    if(typeof urlState !== 'undefined'){
      document.getElementById('satToggle').checked = !!urlState.sat;
      esriLayer.setVisible(!!urlState.sat);
      osmLayer.setVisible(!urlState.sat);

      document.getElementById('heatToggle').checked = !!urlState.heat;
      if(urlState.heat){
        heatmapLayer.setVisible(true);
        document.getElementById('clusterToggle').checked = false;
        clusteredPointLayer.setVisible(false);
        plainPointLayer.setVisible(true);
      } else {
        document.getElementById('clusterToggle').checked = (urlState.cluster !== false);
        clusteredPointLayer.setVisible(document.getElementById('clusterToggle').checked);
        plainPointLayer.setVisible(!document.getElementById('clusterToggle').checked);
      }
    }

// -------- Mobile panel toggle
    const panel=document.getElementById('panel');
    const panelBtn=document.getElementById('panelToggleBtn');
    function isMobile(){return window.matchMedia('(max-width: 820px)').matches;}
    function syncPanelUI(){ if(isMobile()){panelBtn.style.display='block'; panel.classList.remove('open');} else {panelBtn.style.display='none'; panel.classList.add('open');} }
    function closePanelOnMobile(){ if(isMobile()) panel.classList.remove('open'); }
    panelBtn.addEventListener('click', ()=> panel.classList.toggle('open'));
    window.addEventListener('resize', syncPanelUI);
    syncPanelUI();
  
    
    // -------- Dynamic folder counts based on zoom
    function updateFoldersInView(){
      const extent = map.getView().calculateExtent(map.getSize());
      const inViewCounts = new Map();

      pointSource.forEachFeatureIntersectingExtent(extent, f => {
        const folder = f.get('folderPath') || 'Uncategorised';
        inViewCounts.set(folder, (inViewCounts.get(folder) || 0) + 1);
      });

      otherSource.forEachFeatureIntersectingExtent(extent, f => {
        const folder = f.get('folderPath') || 'Uncategorised';
        inViewCounts.set(folder, (inViewCounts.get(folder) || 0) + 1);
      });

      document.querySelectorAll('#folders .folder').forEach(row => {
        const name = row.querySelector('.name')?.textContent?.trim();
        const label = row.querySelector('.inView');
        const count = inViewCounts.get(name) || 0;

        if(label) label.textContent = `${count} in view`;
        row.style.opacity = count ? '1' : '0.35';
      });
    }

    map.on('moveend', ()=>{ setTimeout(()=>updateFoldersInView(), 0); });
    

    // -------- Debug helpers
    function extentToStr(ext){
      if(!ext || ext.length !== 4) return '(none)';
      return ext.map(v => Number.isFinite(v) ? v.toFixed(2) : String(v)).join(', ');
    }
    function setDebug(msg){
      const el = document.getElementById('debugText');
      if(el) el.textContent = msg;
      else if(window.__appendDebug) window.__appendDebug(msg);
    }

    // Wire debug buttons
    document.getElementById('fitBtn').onclick = ()=> { try{ fitToAll();
        requestAnimationFrame(()=>updateFoldersInView()); }catch(e){} };
    document.getElementById('showAllBtn').onclick = ()=> {
      // turn on all folders that exist
      const cbs = document.querySelectorAll('#folders input[type=checkbox]');
      cbs.forEach(cb => cb.checked = true);
      // rebuild enabledFolders from UI
      enabledFolders.clear();
      document.querySelectorAll('#folders .folder').forEach(row => {
        const name = row.querySelector('.name')?.textContent?.trim();
        const cb = row.querySelector('input[type=checkbox]');
        if(name && cb && cb.checked) enabledFolders.add(name);
      });
      otherLayer.changed(); clusteredPointLayer.changed(); plainPointLayer.changed(); heatmapLayer.changed();
      renderList(document.getElementById('search').value);
    };
    document.getElementById('hideAllBtn').onclick = ()=> {
      enabledFolders.clear();
      document.querySelectorAll('#folders input[type=checkbox]').forEach(cb => cb.checked = false);
      otherLayer.changed(); clusteredPointLayer.changed(); plainPointLayer.changed(); heatmapLayer.changed();
      renderList(document.getElementById('search').value);
      overlay.setPosition(undefined); container.style.display='none';
    };


    // -------- Debug toggle (optional)
    const debugPanel = document.getElementById('debug');
    const debugToggleBtn = document.getElementById('debugToggle');
    if(debugPanel) debugPanel.style.display = 'block';
    if(debugToggleBtn){
      debugToggleBtn.textContent = 'Debug';
      debugToggleBtn.onclick = () => {
        try{ debugPanel.scrollIntoView({behavior:'smooth', block:'nearest'}); }catch(e){}
      };
    }

</script>
</body>
</html>
